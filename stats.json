{"errors":[],"warnings":["ship.js from UglifyJs\nDropping unused variable translate [ship.js:79,9]\nCondition always true [ship.js:1021,4]\nCondition always true [ship.js:1043,14]\nDropping unreachable code [ship.js:1046,5]"],"version":"1.9.10","hash":"786148443c5b05b46ed4","time":3531,"publicPath":"/","assetsByChunkName":{"ship":"ship.js"},"assets":[{"name":"ship.js","size":23288,"chunks":[0],"chunkNames":["ship"],"emitted":true}],"chunks":[{"id":0,"rendered":true,"initial":true,"entry":true,"extraAsync":false,"size":51075,"names":["ship"],"files":["ship.js"],"hash":"7ea702cfa01eac41690a","parents":[],"modules":[{"id":0,"identifier":"/Users/romain/Sites/Ships/landing-page/node_modules/babel-loader/index.js!/Users/romain/Sites/Ships/landing-page/src/ship.js","name":"./src/ship.js","size":1678,"cacheable":true,"built":true,"optional":false,"prefetched":false,"chunks":[0],"assets":[],"issuer":null,"failed":false,"errors":0,"warnings":0,"reasons":[],"source":"'use strict';\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\nvar _componentsStyles = require('./components/styles');\n\nvar _componentsStyles2 = _interopRequireDefault(_componentsStyles);\n\nvar _componentsTemplate = require('./components/template');\n\nvar _componentsTemplate2 = _interopRequireDefault(_componentsTemplate);\n\n(function () {\n\n  var getResizedImage = function getResizedImage(img, render) {\n    return 'http://proxy.boxresizer.com/convert?resize=500x332&source=' + encodeURIComponent(img);\n  };\n\n  var start = function start(rootElement, deployment, hull) {\n    var translate = function translate(string) {\n      return deployment.ship.translations.en[string];\n    };\n\n    var settings = deployment.ship.settings;\n    var translations = deployment.ship.translations.en;\n\n    var content = [];\n\n    var styles = (0, _componentsStyles2['default'])(settings);\n    content.push(styles);\n\n    var view = { settings: settings, translations: translations };\n    view.settings.logo = getResizedImage(view.settings.logo);\n\n    content.push((0, _componentsTemplate2['default'])('logo', view));\n    content.push((0, _componentsTemplate2['default'])('header', view));\n    content.push((0, _componentsTemplate2['default'])('tagline', view));\n    content.push((0, _componentsTemplate2['default'])('content', view));\n    content.push((0, _componentsTemplate2['default'])('cta', view));\n    content.push((0, _componentsTemplate2['default'])('images', view));\n\n    $(rootElement).find('.ship-root').empty().append('<div class=\"content\"><div class=\"container\">' + content.join('') + '</div></div>');\n  };\n  Hull.onEmbed(start);\n})();"},{"id":1,"identifier":"/Users/romain/Sites/Ships/landing-page/node_modules/babel-loader/index.js!/Users/romain/Sites/Ships/landing-page/src/components/styles.js","name":"./src/components/styles.js","size":1973,"cacheable":true,"built":true,"optional":false,"prefetched":false,"chunks":[0],"assets":[],"issuer":"/Users/romain/Sites/Ships/landing-page/node_modules/babel-loader/index.js!/Users/romain/Sites/Ships/landing-page/src/ship.js","failed":false,"errors":0,"warnings":0,"reasons":[{"moduleId":0,"moduleIdentifier":"/Users/romain/Sites/Ships/landing-page/node_modules/babel-loader/index.js!/Users/romain/Sites/Ships/landing-page/src/ship.js","module":"./src/ship.js","moduleName":"./src/ship.js","type":"cjs require","userRequest":"./components/styles","loc":"5:24-54"}],"source":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { \"default\": obj }; }\n\nvar _colorJs = require(\"color-js\");\n\nvar _colorJs2 = _interopRequireDefault(_colorJs);\n\nexports[\"default\"] = function (settings) {\n  var style = \"\\n    .ship-root {\\n      background: \" + settings.background_color + \";\\n      color: \" + settings.text_color + \";\\n    }\\n    h1, h2, h3, h4, h5, h6{\\n      color: \" + settings.title_color + \";\\n    }\\n    h1 small, h2 small, h3 small, h4 small, h5 small, h6 small{\\n      color: \" + (0, _colorJs2[\"default\"])(settings.title_color).setAlpha(0.6).toCSS() + \";\\n    }\\n    .btn{\\n      -webkit-border-radius:\" + settings.button_border_radius + \"px;\\n      -moz-border-radius:\" + settings.button_border_radius + \"px;\\n      -o-border-radius:\" + settings.button_border_radius + \"px;\\n      border-radius:\" + settings.button_border_radius + \"px;\\n    }\\n    .btn-main{\\n      color: \" + settings.button_text_color + \";\\n      border-color: \" + (0, _colorJs2[\"default\"])(settings.button_background_color).darkenByRatio(0.1).toCSS() + \";\\n      background-color: \" + settings.button_background_color + \";\\n    }\\n    .content::after{\\n      -webkit-filter: blur(\" + settings.background_blur + \"px);\\n      -moz-filter: blur(\" + settings.background_blur + \"px);\\n      -o-filter: blur(\" + settings.background_blur + \"px);\\n      -ms-filter: blur(\" + settings.background_blur + \"px);\\n      filter: blur(\" + settings.background_blur + \"px);\\n      opacity: \" + settings.background_opacity + \";\\n      position: absolute;\\n      z-index:-1;\\n      top:0;\\n      left:0;\\n      right:0;\\n      bottom:0;\\n      background:url('\" + settings.background_image + \"') repeat-x center top;\\n      background-size:cover;\\n    }\\n  \" + \".content::after{content:''}\";\n  return \"<style type='text/css'>\" + style + \"</style>\";\n};\n\nmodule.exports = exports[\"default\"];"},{"id":2,"identifier":"/Users/romain/Sites/Ships/landing-page/node_modules/babel-loader/index.js!/Users/romain/Sites/Ships/landing-page/src/components/template.js","name":"./src/components/template.js","size":2173,"cacheable":true,"built":true,"optional":false,"prefetched":false,"chunks":[0],"assets":[],"issuer":"/Users/romain/Sites/Ships/landing-page/node_modules/babel-loader/index.js!/Users/romain/Sites/Ships/landing-page/src/ship.js","failed":false,"errors":0,"warnings":0,"reasons":[{"moduleId":0,"moduleIdentifier":"/Users/romain/Sites/Ships/landing-page/node_modules/babel-loader/index.js!/Users/romain/Sites/Ships/landing-page/src/ship.js","module":"./src/ship.js","moduleName":"./src/ship.js","type":"cjs require","userRequest":"./components/template","loc":"9:26-58"}],"source":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { \"default\": obj }; }\n\nvar _mustache = require(\"mustache\");\n\nvar _mustache2 = _interopRequireDefault(_mustache);\n\nvar templates = {\n  logo: \"\\n    {{#settings.logo}}\\n      <div class=\\\"row logo_row\\\">\\n        <div class=\\\"mb-2 mt-1\\\">\\n          {{#settings.cta_link}}<a href=\\\"{{settings.cta_link}}\\\" target=\\\"_top\\\">{{/settings.cta_link}}\\n           <img src=\\\"{{settings.logo}}\\\" alt=\\\"\\\" width=\\\"160\\\" />\\n          {{#settings.cta_link}}</a>{{/settings.cta_link}}\\n        </div>\\n      </div\\n    {{/settings.logo}}\\n  \",\n\n  header: \"\\n    {{#translations.header}}\\n      <div class=\\\"row\\\">\\n        <div class=\\\"col-sm-12\\\">\\n          <h1>{{{translations.header}}}</h1>\\n        </div>\\n      </div>\\n    {{/translations.header}}\\n  \",\n\n  tagline: \"\\n    {{#translations.tagline}}\\n      <div class=\\\"row\\\">\\n        <div class=\\\"col-sm-12\\\">\\n          <h3>{{{translations.tagline}}}</h3>\\n        </div>\\n      </div>\\n    {{/translations.tagline}}\\n  \",\n\n  content: \"\\n    <div class=\\\"row\\\">\\n      <div class=\\\"col-sm-12\\\">\\n        <p>{{{translations.content}}}</p>\\n      </div>\\n    </div>\\n  \",\n\n  cta: \"\\n    {{#settings.cta_link}}\\n      <div class=\\\"row mt-2\\\">\\n        <div class=\\\"col-sm-8 col-sm-offset-2 col-md-6 col-md-offset-3\\\">\\n          <a href={{settings.cta_link}} class='btn btn-main btn-lg btn-block'>\\n            <span>{{{translations.call_to_action}}}</span>\\n          </a>\\n        </div>\\n      </div>\\n    {{/settings.cta_link}}\\n  \",\n\n  images: \"\\n    <div class=\\\"images pt-4 pb-4 row flex-row\\\">\\n      {{#settings.images}}\\n        <div class=\\\"col-xs-2 small-ps flex-item\\\">\\n          <img src=\\\"{{.}}\\\" class=\\\"img-responsive\\\" />\\n        </div>\\n      {{/settings.images}}\\n    </div>\\n  \"\n};\n\nexports[\"default\"] = function (template) {\n  var data = arguments[1] === undefined ? {} : arguments[1];\n\n  var t = templates[template];\n  if (t) {\n    return _mustache2[\"default\"].render(t, data);\n  } else {\n    return \"\";\n  }\n};\n\nmodule.exports = exports[\"default\"];"},{"id":3,"identifier":"/Users/romain/Sites/Ships/landing-page/node_modules/color-js/color.js","name":"./~/color-js/color.js","size":27073,"cacheable":true,"built":true,"optional":false,"prefetched":false,"chunks":[0],"assets":[],"issuer":"/Users/romain/Sites/Ships/landing-page/node_modules/babel-loader/index.js!/Users/romain/Sites/Ships/landing-page/src/components/styles.js","failed":false,"errors":0,"warnings":0,"reasons":[{"moduleId":1,"moduleIdentifier":"/Users/romain/Sites/Ships/landing-page/node_modules/babel-loader/index.js!/Users/romain/Sites/Ships/landing-page/src/components/styles.js","module":"./src/components/styles.js","moduleName":"./src/components/styles.js","type":"cjs require","userRequest":"color-js","loc":"9:15-34"}],"source":"// Copyright (c) 2008-2013, Andrew Brehaut, Tim Baumann, Matt Wilson, \n//                          Simon Heimler, Michel Vielmetter \n//\n// All rights reserved.\n//\n// Redistribution and use in source and binary forms, with or without\n// modification, are permitted provided that the following conditions are met:\n//\n// * Redistributions of source code must retain the above copyright notice,\n//   this list of conditions and the following disclaimer.\n// * Redistributions in binary form must reproduce the above copyright notice,\n//   this list of conditions and the following disclaimer in the documentation\n//   and/or other materials provided with the distribution.\n//\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n// ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE\n// LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n// CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n// SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n// INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n// CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n// POSSIBILITY OF SUCH DAMAGE.\n\n// color.js - version 1.0.1\n//\n// HSV <-> RGB code based on code from http://www.cs.rit.edu/~ncs/color/t_convert.html\n// object function created by Douglas Crockford.\n// Color scheme degrees taken from the colorjack.com colorpicker\n//\n// HSL support kindly provided by Tim Baumann - http://github.com/timjb\n\n// create namespaces\n/*global net */\nif (\"undefined\" == typeof net) { var net = {}; }\nif (!net.brehaut) { net.brehaut = {}; }\n\n// this module function is called with net.brehaut as 'this'\n(function ( ) {\n  \"use strict\";\n  // Constants\n\n  // css_colors maps color names onto their hex values\n  // these names are defined by W3C\n  var css_colors = {aliceblue:'#F0F8FF',antiquewhite:'#FAEBD7',aqua:'#00FFFF',aquamarine:'#7FFFD4',azure:'#F0FFFF',beige:'#F5F5DC',bisque:'#FFE4C4',black:'#000000',blanchedalmond:'#FFEBCD',blue:'#0000FF',blueviolet:'#8A2BE2',brown:'#A52A2A',burlywood:'#DEB887',cadetblue:'#5F9EA0',chartreuse:'#7FFF00',chocolate:'#D2691E',coral:'#FF7F50',cornflowerblue:'#6495ED',cornsilk:'#FFF8DC',crimson:'#DC143C',cyan:'#00FFFF',darkblue:'#00008B',darkcyan:'#008B8B',darkgoldenrod:'#B8860B',darkgray:'#A9A9A9',darkgrey:'#A9A9A9',darkgreen:'#006400',darkkhaki:'#BDB76B',darkmagenta:'#8B008B',darkolivegreen:'#556B2F',darkorange:'#FF8C00',darkorchid:'#9932CC',darkred:'#8B0000',darksalmon:'#E9967A',darkseagreen:'#8FBC8F',darkslateblue:'#483D8B',darkslategray:'#2F4F4F',darkslategrey:'#2F4F4F',darkturquoise:'#00CED1',darkviolet:'#9400D3',deeppink:'#FF1493',deepskyblue:'#00BFFF',dimgray:'#696969',dimgrey:'#696969',dodgerblue:'#1E90FF',firebrick:'#B22222',floralwhite:'#FFFAF0',forestgreen:'#228B22',fuchsia:'#FF00FF',gainsboro:'#DCDCDC',ghostwhite:'#F8F8FF',gold:'#FFD700',goldenrod:'#DAA520',gray:'#808080',grey:'#808080',green:'#008000',greenyellow:'#ADFF2F',honeydew:'#F0FFF0',hotpink:'#FF69B4',indianred:'#CD5C5C',indigo:'#4B0082',ivory:'#FFFFF0',khaki:'#F0E68C',lavender:'#E6E6FA',lavenderblush:'#FFF0F5',lawngreen:'#7CFC00',lemonchiffon:'#FFFACD',lightblue:'#ADD8E6',lightcoral:'#F08080',lightcyan:'#E0FFFF',lightgoldenrodyellow:'#FAFAD2',lightgray:'#D3D3D3',lightgrey:'#D3D3D3',lightgreen:'#90EE90',lightpink:'#FFB6C1',lightsalmon:'#FFA07A',lightseagreen:'#20B2AA',lightskyblue:'#87CEFA',lightslategray:'#778899',lightslategrey:'#778899',lightsteelblue:'#B0C4DE',lightyellow:'#FFFFE0',lime:'#00FF00',limegreen:'#32CD32',linen:'#FAF0E6',magenta:'#FF00FF',maroon:'#800000',mediumaquamarine:'#66CDAA',mediumblue:'#0000CD',mediumorchid:'#BA55D3',mediumpurple:'#9370D8',mediumseagreen:'#3CB371',mediumslateblue:'#7B68EE',mediumspringgreen:'#00FA9A',mediumturquoise:'#48D1CC',mediumvioletred:'#C71585',midnightblue:'#191970',mintcream:'#F5FFFA',mistyrose:'#FFE4E1',moccasin:'#FFE4B5',navajowhite:'#FFDEAD',navy:'#000080',oldlace:'#FDF5E6',olive:'#808000',olivedrab:'#6B8E23',orange:'#FFA500',orangered:'#FF4500',orchid:'#DA70D6',palegoldenrod:'#EEE8AA',palegreen:'#98FB98',paleturquoise:'#AFEEEE',palevioletred:'#D87093',papayawhip:'#FFEFD5',peachpuff:'#FFDAB9',peru:'#CD853F',pink:'#FFC0CB',plum:'#DDA0DD',powderblue:'#B0E0E6',purple:'#800080',rebeccapurple:'#663399',red:'#FF0000',rosybrown:'#BC8F8F',royalblue:'#4169E1',saddlebrown:'#8B4513',salmon:'#FA8072',sandybrown:'#F4A460',seagreen:'#2E8B57',seashell:'#FFF5EE',sienna:'#A0522D',silver:'#C0C0C0',skyblue:'#87CEEB',slateblue:'#6A5ACD',slategray:'#708090',slategrey:'#708090',snow:'#FFFAFA',springgreen:'#00FF7F',steelblue:'#4682B4',tan:'#D2B48C',teal:'#008080',thistle:'#D8BFD8',tomato:'#FF6347',turquoise:'#40E0D0',violet:'#EE82EE',wheat:'#F5DEB3',white:'#FFFFFF',whitesmoke:'#F5F5F5',yellow:'#FFFF00',yellowgreen:'#9ACD32'};\n\n  // CSS value regexes, according to http://www.w3.org/TR/css3-values/\n  var css_integer = '(?:\\\\+|-)?\\\\d+';\n  var css_float = '(?:\\\\+|-)?\\\\d*\\\\.\\\\d+';\n  var css_number = '(?:' + css_integer + ')|(?:' + css_float + ')';\n  css_integer = '(' + css_integer + ')';\n  css_float = '(' + css_float + ')';\n  css_number = '(' + css_number + ')';\n  var css_percentage = css_number + '%';\n  var css_whitespace = '\\\\s*?';\n\n  // http://www.w3.org/TR/2003/CR-css3-color-20030514/\n  var hsl_hsla_regex = new RegExp([\n    '^hsl(a?)\\\\(', css_number, ',', css_percentage, ',', css_percentage, '(,(', css_number, '))?\\\\)$'\n  ].join(css_whitespace) );\n  var rgb_rgba_integer_regex = new RegExp([\n    '^rgb(a?)\\\\(', css_integer, ',', css_integer, ',', css_integer, '(,(', css_number, '))?\\\\)$'\n  ].join(css_whitespace) );\n  var rgb_rgba_percentage_regex = new RegExp([\n    '^rgb(a?)\\\\(', css_percentage, ',', css_percentage, ',', css_percentage, '(,(', css_number, '))?\\\\)$'\n  ].join(css_whitespace) );\n\n  // Package wide variables\n\n  // becomes the top level prototype object\n  var color;\n\n  /* registered_models contains the template objects for all the\n   * models that have been registered for the color class.\n   */\n  var registered_models = [];\n\n\n  /* factories contains methods to create new instance of\n   * different color models that have been registered.\n   */\n  var factories = {};\n\n  // Utility functions\n\n  /* object is Douglas Crockfords object function for prototypal\n   * inheritance.\n   */\n  if (!this.object) {\n    this.object = function (o) {\n      function F () { }\n      F.prototype = o;\n      return new F();\n    };\n  }\n  var object = this.object;\n\n  /* takes a value, converts to string if need be, then pads it\n   * to a minimum length.\n   */\n  function pad ( val, len ) {\n    val = val.toString();\n    var padded = [];\n\n    for (var i = 0, j = Math.max( len - val.length, 0); i < j; i++) {\n      padded.push('0');\n    }\n\n    padded.push(val);\n    return padded.join('');\n  }\n\n\n  /* takes a string and returns a new string with the first letter\n   * capitalised\n   */\n  function capitalise ( s ) {\n    return s.slice(0,1).toUpperCase() + s.slice(1);\n  }\n\n  /* removes leading and trailing whitespace\n   */\n  function trim ( str ) {\n    return str.replace(/^\\s+|\\s+$/g, '');\n  }\n\n  /* used to apply a method to object non-destructively by\n   * cloning the object and then apply the method to that\n   * new object\n   */\n  function cloneOnApply( meth ) {\n    return function ( ) {\n      var cloned = this.clone();\n      meth.apply(cloned, arguments);\n      return cloned;\n    };\n  }\n\n\n  /* registerModel is used to add additional representations\n   * to the color code, and extend the color API with the new\n   * operation that model provides. see before for examples\n   */\n  function registerModel( name, model ) {\n    var proto = object(color);\n    var fields = []; // used for cloning and generating accessors\n\n    var to_meth = 'to'+ capitalise(name);\n\n    function convertAndApply( meth ) {\n      return function ( ) {\n        return meth.apply(this[to_meth](), arguments);\n      };\n    }\n\n    for (var key in model) if (model.hasOwnProperty(key)) {\n      proto[key] = model[key];\n      var prop = proto[key];\n\n      if (key.slice(0,1) == '_') { continue; }\n      if (!(key in color) && \"function\" == typeof prop) {\n        // the method found on this object is a) public and b) not\n        // currently supported by the color object. Create an impl that\n        // calls the toModel function and passes that new object\n        // onto the correct method with the args.\n        color[key] = convertAndApply(prop);\n      }\n      else if (\"function\" != typeof prop) {\n        // we have found a public property. create accessor methods\n        // and bind them up correctly\n        fields.push(key);\n        var getter = 'get'+capitalise(key);\n        var setter = 'set'+capitalise(key);\n\n        color[getter] = convertAndApply(\n          proto[getter] = (function ( key ) {\n            return function ( ) {\n              return this[key];\n            };\n          })( key )\n        );\n\n        color[setter] = convertAndApply(\n          proto[setter] = (function ( key ) {\n            return function ( val ) {\n              var cloned = this.clone();\n              cloned[key] = val;\n              return cloned;\n            };\n          })( key )\n        );\n      }\n    } // end of for over model\n\n    // a method to create a new object - largely so prototype chains dont\n    // get insane. This uses an unrolled 'object' so that F is cached\n    // for later use. this is approx a 25% speed improvement\n    function F () { }\n    F.prototype = proto;\n    function factory ( ) {\n      return new F();\n    }\n    factories[name] = factory;\n\n    proto.clone = function () {\n      var cloned = factory();\n      for (var i = 0, j = fields.length; i < j; i++) {\n        var key = fields[i];\n        cloned[key] = this[key];\n      }\n      return cloned;\n    };\n\n    color[to_meth] = function ( ) {\n      return factory();\n    };\n\n    registered_models.push(proto);\n\n    return proto;\n  }// end of registerModel\n\n  // Template Objects\n\n  /* color is the root object in the color hierarchy. It starts\n   * life as a very simple object, but as color models are\n   * registered it has methods programmatically added to manage\n   * conversions as needed.\n   */\n  color = {\n    /* fromObject takes an argument and delegates to the internal\n     * color models to try to create a new instance.\n     */\n    fromObject: function ( o ) {\n      if (!o) {\n        return object(color);\n      }\n\n      for (var i = 0, j = registered_models.length; i < j; i++) {\n        var nu = registered_models[i].fromObject(o);\n        if (nu) {\n          return nu;\n        }\n      }\n\n      return object(color);\n    },\n\n    toString: function ( ) {\n      return this.toCSS();\n    }\n  };\n\n  var transparent = null; // defined with an RGB later.\n\n  /* RGB is the red green blue model. This definition is converted\n   * to a template object by registerModel.\n   */\n  registerModel('RGB', {\n    red:    0,\n    green:  0,\n    blue:   0,\n    alpha:  0,\n\n    /* getLuminance returns a value between 0 and 1, this is the\n     * luminance calcuated according to\n     * http://www.poynton.com/notes/colour_and_gamma/ColorFAQ.html#RTFToC9\n     */\n    getLuminance: function ( ) {\n      return (this.red * 0.2126) + (this.green * 0.7152) + (this.blue * 0.0722);\n    },\n\n    /* does an alpha based blend of color onto this. alpha is the\n     * amount of 'color' to use. (0 to 1)\n     */\n    blend: function ( color , alpha ) {\n      color = color.toRGB();\n      alpha = Math.min(Math.max(alpha, 0), 1);\n      var rgb = this.clone();     \n\n      rgb.red = (rgb.red * (1 - alpha)) + (color.red * alpha);\n      rgb.green = (rgb.green * (1 - alpha)) + (color.green * alpha);\n      rgb.blue = (rgb.blue * (1 - alpha)) + (color.blue * alpha);\n      rgb.alpha = (rgb.alpha * (1 - alpha)) + (color.alpha * alpha);\n\n      return rgb;\n    },\n\n    /* fromObject attempts to convert an object o to and RGB\n     * instance. This accepts an object with red, green and blue\n     * members or a string. If the string is a known CSS color name\n     * or a hexdecimal string it will accept it.\n     */\n    fromObject: function ( o ) {\n      if (o instanceof Array) {\n        return this._fromRGBArray ( o );\n      }\n      if (\"string\" == typeof o) {\n        return this._fromCSS( trim( o ) );\n      }\n      if (o.hasOwnProperty('red') &&\n          o.hasOwnProperty('green') &&\n          o.hasOwnProperty('blue')) {\n        return this._fromRGB ( o );\n      }\n      // nothing matchs, not an RGB object\n    },\n\n    _stringParsers: [\n        // CSS RGB(A) literal:\n        function ( css ) {\n          css = trim(css);\n\n          var withInteger = match(rgb_rgba_integer_regex, 255);\n          if(withInteger) {\n            return withInteger;\n          }\n          return match(rgb_rgba_percentage_regex, 100);\n\n          function match(regex, max_value) {\n            var colorGroups = css.match( regex );\n\n            // If there is an \"a\" after \"rgb\", there must be a fourth parameter and the other way round\n            if (!colorGroups || (!!colorGroups[1] + !!colorGroups[5] === 1)) {\n              return null;\n            }\n\n            var rgb = factories.RGB();\n            rgb.red   = Math.min(1, Math.max(0, colorGroups[2] / max_value));\n            rgb.green = Math.min(1, Math.max(0, colorGroups[3] / max_value));\n            rgb.blue  = Math.min(1, Math.max(0, colorGroups[4] / max_value));\n            rgb.alpha = !!colorGroups[5] ? Math.min(Math.max(parseFloat(colorGroups[6]), 0), 1) : 1;\n\n            return rgb;\n          }\n        },\n\n        function ( css ) {\n            var lower = css.toLowerCase();\n            if (lower in css_colors) {\n              css = css_colors[lower];\n            }\n\n            if (!css.match(/^#([0-9a-fA-F]{3}|[0-9a-fA-F]{6})$/)) {\n              return;\n            }\n\n            css = css.replace(/^#/,'');\n\n            var bytes = css.length / 3;\n\n            var max = Math.pow(16, bytes) - 1;\n\n            var rgb = factories.RGB();\n            rgb.red =   parseInt(css.slice(0, bytes), 16) / max;\n            rgb.green = parseInt(css.slice(bytes * 1,bytes * 2), 16) / max;\n            rgb.blue =  parseInt(css.slice(bytes * 2), 16) / max;\n            rgb.alpha = 1;\n            return rgb;\n        },\n\n        function ( css ) {\n            if (css.toLowerCase() !== 'transparent') return;\n\n            return transparent;\n        }\n    ],\n\n    _fromCSS: function ( css ) {\n      var color = null;\n      for (var i = 0, j = this._stringParsers.length; i < j; i++) {\n          color = this._stringParsers[i](css);\n          if (color) return color;\n      }\n    },\n\n    _fromRGB: function ( RGB ) {\n      var newRGB = factories.RGB();\n\n      newRGB.red = RGB.red;\n      newRGB.green = RGB.green;\n      newRGB.blue = RGB.blue;\n      newRGB.alpha = RGB.hasOwnProperty('alpha') ? RGB.alpha : 1;\n\n      return newRGB;\n    },\n\n    _fromRGBArray: function ( RGB ) {\n      var newRGB = factories.RGB();\n\n      newRGB.red = Math.max(0, Math.min(1, RGB[0] / 255));\n      newRGB.green = Math.max(0, Math.min(1, RGB[1] / 255));\n      newRGB.blue = Math.max(0, Math.min(1, RGB[2] / 255));\n      newRGB.alpha = RGB[3] !== undefined ? Math.max(0, Math.min(1, RGB[3])) : 1;\n\n      return newRGB;\n    },\n\n    // convert to a CSS string. defaults to two bytes a value\n    toCSSHex: function ( bytes ) {\n        bytes = bytes || 2;\n\n        var max = Math.pow(16, bytes) - 1;\n        var css = [\n          \"#\",\n          pad ( Math.round(this.red * max).toString( 16 ).toUpperCase(), bytes ),\n          pad ( Math.round(this.green * max).toString( 16 ).toUpperCase(), bytes ),\n          pad ( Math.round(this.blue * max).toString( 16 ).toUpperCase(), bytes )\n        ];\n\n        return css.join('');\n    },    \n    \n    toCSS: function ( bytes ) {\n      if (this.alpha === 1) return this.toCSSHex(bytes); \n\n      var max = 255;\n      \n      var components = [\n        'rgba(',\n        Math.max(0, Math.min(max, Math.round(this.red * max))), ',',\n        Math.max(0, Math.min(max, Math.round(this.green * max))), ',', \n        Math.max(0, Math.min(max, Math.round(this.blue * max))), ',',\n        Math.max(0, Math.min(1, this.alpha)), \n        ')'\n      ];\n\n      return components.join('');\n    },\n\n    toHSV: function ( ) {\n      var hsv = factories.HSV();\n      var min, max, delta;\n\n      min = Math.min(this.red, this.green, this.blue);\n      max = Math.max(this.red, this.green, this.blue);\n      hsv.value = max; // v\n\n      delta = max - min;\n\n      if( delta == 0 ) { // white, grey, black\n        hsv.hue = hsv.saturation = 0;\n      }\n      else { // chroma\n        hsv.saturation = delta / max;\n\n        if( this.red == max ) {\n          hsv.hue = ( this.green - this.blue ) / delta; // between yellow & magenta\n        }\n        else if( this.green  == max ) {\n          hsv.hue = 2 + ( this.blue - this.red ) / delta; // between cyan & yellow\n        }\n        else {\n          hsv.hue = 4 + ( this.red - this.green ) / delta; // between magenta & cyan\n        }\n\n        hsv.hue = ((hsv.hue * 60) + 360) % 360; // degrees\n      }\n\n      hsv.alpha = this.alpha;\n\n      return hsv;\n    },\n    toHSL: function ( ) {\n      return this.toHSV().toHSL();\n    },\n\n    toRGB: function ( ) {\n      return this.clone();\n    }\n  });\n\n  transparent = color.fromObject({red: 0, blue: 0, green: 0, alpha: 0});\n\n\n  /* Like RGB above, this object describes what will become the HSV\n   * template object. This model handles hue, saturation and value.\n   * hue is the number of degrees around the color wheel, saturation\n   * describes how much color their is and value is the brightness.\n   */\n  registerModel('HSV', {\n    hue: 0,\n    saturation: 0,\n    value: 1,\n    alpha: 1,\n\n    shiftHue: cloneOnApply(function ( degrees ) {\n      var hue = (this.hue + degrees) % 360;\n      if (hue < 0) {\n        hue = (360 + hue) % 360;\n      }\n\n      this.hue = hue;\n    }),\n\n    devalueByAmount: cloneOnApply(function ( val ) {\n      this.value = Math.min(1, Math.max(this.value - val, 0));\n    }),\n\n    devalueByRatio: cloneOnApply(function ( val ) {\n      this.value = Math.min(1, Math.max(this.value * (1 - val), 0));\n    }),\n\n    valueByAmount: cloneOnApply(function ( val ) {\n      this.value = Math.min(1, Math.max(this.value + val, 0));\n    }),\n\n    valueByRatio: cloneOnApply(function ( val ) {\n      this.value = Math.min(1, Math.max(this.value * (1 + val), 0));\n    }),\n\n    desaturateByAmount: cloneOnApply(function ( val ) {\n      this.saturation = Math.min(1, Math.max(this.saturation - val, 0));\n    }),\n\n    desaturateByRatio: cloneOnApply(function ( val ) {\n      this.saturation = Math.min(1, Math.max(this.saturation * (1 - val), 0));\n    }),\n\n    saturateByAmount: cloneOnApply(function ( val ) {\n      this.saturation = Math.min(1, Math.max(this.saturation + val, 0));\n    }),\n\n    saturateByRatio: cloneOnApply(function ( val ) {\n      this.saturation = Math.min(1, Math.max(this.saturation * (1 + val), 0));\n    }),\n\n    schemeFromDegrees: function ( degrees ) {\n      var newColors = [];\n      for (var i = 0, j = degrees.length; i < j; i++) {\n        var col = this.clone();\n        col.hue = (this.hue + degrees[i]) % 360;\n        newColors.push(col);\n      }\n      return newColors;\n    },\n\n    complementaryScheme: function ( ) {\n      return this.schemeFromDegrees([0,180]);\n    },\n\n    splitComplementaryScheme: function ( ) {\n      return this.schemeFromDegrees([0,150,320]);\n    },\n\n    splitComplementaryCWScheme: function ( ) {\n      return this.schemeFromDegrees([0,150,300]);\n    },\n\n    splitComplementaryCCWScheme: function ( ) {\n      return this.schemeFromDegrees([0,60,210]);\n    },\n\n    triadicScheme: function ( ) {\n      return this.schemeFromDegrees([0,120,240]);\n    },\n\n    clashScheme: function ( ) {\n      return this.schemeFromDegrees([0,90,270]);\n    },\n\n    tetradicScheme: function ( ) {\n      return this.schemeFromDegrees([0,90,180,270]);\n    },\n\n    fourToneCWScheme: function ( ) {\n      return this.schemeFromDegrees([0,60,180,240]);\n    },\n\n    fourToneCCWScheme: function ( ) {\n      return this.schemeFromDegrees([0,120,180,300]);\n    },\n\n    fiveToneAScheme: function ( ) {\n      return this.schemeFromDegrees([0,115,155,205,245]);\n    },\n\n    fiveToneBScheme: function ( ) {\n      return this.schemeFromDegrees([0,40,90,130,245]);\n    },\n\n    fiveToneCScheme: function ( ) {\n      return this.schemeFromDegrees([0,50,90,205,320]);\n    },\n\n    fiveToneDScheme: function ( ) {\n      return this.schemeFromDegrees([0,40,155,270,310]);\n    },\n\n    fiveToneEScheme: function ( ) {\n      return this.schemeFromDegrees([0,115,230,270,320]);\n    },\n\n    sixToneCWScheme: function ( ) {\n      return this.schemeFromDegrees([0,30,120,150,240,270]);\n    },\n\n    sixToneCCWScheme: function ( ) {\n      return this.schemeFromDegrees([0,90,120,210,240,330]);\n    },\n\n    neutralScheme: function ( ) {\n      return this.schemeFromDegrees([0,15,30,45,60,75]);\n    },\n\n    analogousScheme: function ( ) {\n      return this.schemeFromDegrees([0,30,60,90,120,150]);\n    },\n\n    fromObject: function ( o ) {\n      if (o.hasOwnProperty('hue') &&\n          o.hasOwnProperty('saturation') &&\n          o.hasOwnProperty('value')) {\n        var hsv = factories.HSV();\n\n        hsv.hue = o.hue;\n        hsv.saturation = o.saturation;\n        hsv.value = o.value;\n        hsv.alpha = o.hasOwnProperty('alpha') ? o.alpha : 1;\n\n        return hsv;\n      }\n      // nothing matches, not an HSV object\n      return null;\n    },\n\n    _normalise: function ( ) {\n       this.hue %= 360;\n       this.saturation = Math.min(Math.max(0, this.saturation), 1);\n       this.value = Math.min(Math.max(0, this.value));\n       this.alpha = Math.min(1, Math.max(0, this.alpha));\n    },\n\n    toRGB: function ( ) {\n      this._normalise();\n\n      var rgb = factories.RGB();\n      var i;\n      var f, p, q, t;\n\n      if( this.saturation === 0 ) {\n        // achromatic (grey)\n        rgb.red = this.value;\n        rgb.green = this.value;\n        rgb.blue = this.value;\n        rgb.alpha = this.alpha;\n        return rgb;\n      }\n\n      var h = this.hue / 60;\t\t\t// sector 0 to 5\n      i = Math.floor( h );\n      f = h - i;\t\t\t// factorial part of h\n      p = this.value * ( 1 - this.saturation );\n      q = this.value * ( 1 - this.saturation * f );\n      t = this.value * ( 1 - this.saturation * ( 1 - f ) );\n\n      switch( i ) {\n        case 0:\n          rgb.red = this.value;\n          rgb.green = t;\n          rgb.blue = p;\n          break;\n        case 1:\n          rgb.red = q;\n          rgb.green = this.value;\n          rgb.blue = p;\n          break;\n        case 2:\n          rgb.red = p;\n          rgb.green = this.value;\n          rgb.blue = t;\n          break;\n        case 3:\n          rgb.red = p;\n          rgb.green = q;\n          rgb.blue = this.value;\n          break;\n        case 4:\n          rgb.red = t;\n          rgb.green = p;\n          rgb.blue = this.value;\n          break;\n        default:\t\t// case 5:\n          rgb.red = this.value;\n          rgb.green = p;\n          rgb.blue = q;\n          break;\n      }\n\n      rgb.alpha = this.alpha;\n\n      return rgb;\n    },\n    toHSL: function() {\n      this._normalise();\n\n      var hsl = factories.HSL();\n\n      hsl.hue = this.hue;\n      var l = (2 - this.saturation) * this.value,\n          s = this.saturation * this.value;\n      if(l && 2 - l) {\n        s /= (l <= 1) ? l : 2 - l;\n      }\n      l /= 2;\n      hsl.saturation = s;\n      hsl.lightness = l;\n      hsl.alpha = this.alpha;\n\n      return hsl;\n    },\n\n    toHSV: function ( ) {\n      return this.clone();\n    }\n  });\n\n  registerModel('HSL', {\n    hue: 0,\n    saturation: 0,\n    lightness: 0,\n    alpha: 1,\n\n    darkenByAmount: cloneOnApply(function ( val ) {\n      this.lightness = Math.min(1, Math.max(this.lightness - val, 0));\n    }),\n\n    darkenByRatio: cloneOnApply(function ( val ) {\n      this.lightness = Math.min(1, Math.max(this.lightness * (1 - val), 0));\n    }),\n\n    lightenByAmount: cloneOnApply(function ( val ) {\n      this.lightness = Math.min(1, Math.max(this.lightness + val, 0));\n    }),\n\n    lightenByRatio: cloneOnApply(function ( val ) {\n      this.lightness = Math.min(1, Math.max(this.lightness * (1 + val), 0));\n    }),\n\n    fromObject: function ( o ) {\n      if (\"string\" == typeof o) {\n        return this._fromCSS( o );\n      }\n      if (o.hasOwnProperty('hue') &&\n          o.hasOwnProperty('saturation') &&\n          o.hasOwnProperty('lightness')) {\n        return this._fromHSL ( o );\n      }\n      // nothing matchs, not an RGB object\n    },\n\n    _fromCSS: function ( css ) {\n      var colorGroups = trim( css ).match( hsl_hsla_regex );\n\n      // if there is an \"a\" after \"hsl\", there must be a fourth parameter and the other way round\n      if (!colorGroups || (!!colorGroups[1] + !!colorGroups[5] === 1)) {\n        return null;\n      }\n\n      var hsl = factories.HSL();\n      hsl.hue        = (colorGroups[2] % 360 + 360) % 360;\n      hsl.saturation = Math.max(0, Math.min(parseInt(colorGroups[3], 10) / 100, 1));\n      hsl.lightness  = Math.max(0, Math.min(parseInt(colorGroups[4], 10) / 100, 1));\n      hsl.alpha      = !!colorGroups[5] ? Math.max(0, Math.min(1, parseFloat(colorGroups[6]))) : 1;\n\n      return hsl;\n    },\n\n    _fromHSL: function ( HSL ) {\n      var newHSL = factories.HSL();\n\n      newHSL.hue = HSL.hue;\n      newHSL.saturation = HSL.saturation;\n      newHSL.lightness = HSL.lightness;\n\n      newHSL.alpha = HSL.hasOwnProperty('alpha') ? HSL.alpha : 1;\n\n      return newHSL;\n    },\n\n    _normalise: function ( ) {\n       this.hue = (this.hue % 360 + 360) % 360;\n       this.saturation = Math.min(Math.max(0, this.saturation), 1);\n       this.lightness = Math.min(Math.max(0, this.lightness));\n       this.alpha = Math.min(1, Math.max(0, this.alpha));\n    },\n\n    toHSL: function() {\n      return this.clone();\n    },\n    toHSV: function() {\n      this._normalise();\n\n      var hsv = factories.HSV();\n\n      // http://ariya.blogspot.com/2008/07/converting-between-hsl-and-hsv.html\n      hsv.hue = this.hue; // H\n      var l = 2 * this.lightness,\n          s = this.saturation * ((l <= 1) ? l : 2 - l);\n      hsv.value = (l + s) / 2; // V\n      hsv.saturation = ((2 * s) / (l + s)) || 0; // S\n      hsv.alpha = this.alpha;\n\n      return hsv;\n    },\n    toRGB: function() {\n      return this.toHSV().toRGB();\n    }\n  });\n\n  // Package specific exports\n\n  /* the Color function is a factory for new color objects.\n   */\n  function Color( o ) {\n    return color.fromObject( o );\n  }\n  Color.isValid = function( str ) {\n    var key, c = Color( str );\n\n    var length = 0;\n    for(key in c) {\n      if(c.hasOwnProperty(key)) {\n        length++;\n      }\n    }\n\n    return length > 0;\n  };\n  net.brehaut.Color = Color;\n}).call(net.brehaut);\n\n/* Export to CommonJS\n*/\nif(typeof module !== 'undefined') {\n  module.exports = net.brehaut.Color;\n}\n"},{"id":4,"identifier":"/Users/romain/Sites/Ships/landing-page/node_modules/mustache/mustache.js","name":"./~/mustache/mustache.js","size":18178,"cacheable":true,"built":true,"optional":false,"prefetched":false,"chunks":[0],"assets":[],"issuer":"/Users/romain/Sites/Ships/landing-page/node_modules/babel-loader/index.js!/Users/romain/Sites/Ships/landing-page/src/components/template.js","failed":false,"errors":0,"warnings":0,"reasons":[{"moduleId":2,"moduleIdentifier":"/Users/romain/Sites/Ships/landing-page/node_modules/babel-loader/index.js!/Users/romain/Sites/Ships/landing-page/src/components/template.js","module":"./src/components/template.js","moduleName":"./src/components/template.js","type":"cjs require","userRequest":"mustache","loc":"9:16-35"}],"source":"/*!\n * mustache.js - Logic-less {{mustache}} templates with JavaScript\n * http://github.com/janl/mustache.js\n */\n\n/*global define: false*/\n\n(function (global, factory) {\n  if (typeof exports === \"object\" && exports) {\n    factory(exports); // CommonJS\n  } else if (typeof define === \"function\" && define.amd) {\n    define(['exports'], factory); // AMD\n  } else {\n    factory(global.Mustache = {}); // <script>\n  }\n}(this, function (mustache) {\n\n  var Object_toString = Object.prototype.toString;\n  var isArray = Array.isArray || function (object) {\n    return Object_toString.call(object) === '[object Array]';\n  };\n\n  function isFunction(object) {\n    return typeof object === 'function';\n  }\n\n  function escapeRegExp(string) {\n    return string.replace(/[\\-\\[\\]{}()*+?.,\\\\\\^$|#\\s]/g, \"\\\\$&\");\n  }\n\n  // Workaround for https://issues.apache.org/jira/browse/COUCHDB-577\n  // See https://github.com/janl/mustache.js/issues/189\n  var RegExp_test = RegExp.prototype.test;\n  function testRegExp(re, string) {\n    return RegExp_test.call(re, string);\n  }\n\n  var nonSpaceRe = /\\S/;\n  function isWhitespace(string) {\n    return !testRegExp(nonSpaceRe, string);\n  }\n\n  var entityMap = {\n    \"&\": \"&amp;\",\n    \"<\": \"&lt;\",\n    \">\": \"&gt;\",\n    '\"': '&quot;',\n    \"'\": '&#39;',\n    \"/\": '&#x2F;'\n  };\n\n  function escapeHtml(string) {\n    return String(string).replace(/[&<>\"'\\/]/g, function (s) {\n      return entityMap[s];\n    });\n  }\n\n  var whiteRe = /\\s*/;\n  var spaceRe = /\\s+/;\n  var equalsRe = /\\s*=/;\n  var curlyRe = /\\s*\\}/;\n  var tagRe = /#|\\^|\\/|>|\\{|&|=|!/;\n\n  /**\n   * Breaks up the given `template` string into a tree of tokens. If the `tags`\n   * argument is given here it must be an array with two string values: the\n   * opening and closing tags used in the template (e.g. [ \"<%\", \"%>\" ]). Of\n   * course, the default is to use mustaches (i.e. mustache.tags).\n   *\n   * A token is an array with at least 4 elements. The first element is the\n   * mustache symbol that was used inside the tag, e.g. \"#\" or \"&\". If the tag\n   * did not contain a symbol (i.e. {{myValue}}) this element is \"name\". For\n   * all text that appears outside a symbol this element is \"text\".\n   *\n   * The second element of a token is its \"value\". For mustache tags this is\n   * whatever else was inside the tag besides the opening symbol. For text tokens\n   * this is the text itself.\n   *\n   * The third and fourth elements of the token are the start and end indices,\n   * respectively, of the token in the original template.\n   *\n   * Tokens that are the root node of a subtree contain two more elements: 1) an\n   * array of tokens in the subtree and 2) the index in the original template at\n   * which the closing tag for that section begins.\n   */\n  function parseTemplate(template, tags) {\n    if (!template)\n      return [];\n\n    var sections = [];     // Stack to hold section tokens\n    var tokens = [];       // Buffer to hold the tokens\n    var spaces = [];       // Indices of whitespace tokens on the current line\n    var hasTag = false;    // Is there a {{tag}} on the current line?\n    var nonSpace = false;  // Is there a non-space char on the current line?\n\n    // Strips all whitespace tokens array for the current line\n    // if there was a {{#tag}} on it and otherwise only space.\n    function stripSpace() {\n      if (hasTag && !nonSpace) {\n        while (spaces.length)\n          delete tokens[spaces.pop()];\n      } else {\n        spaces = [];\n      }\n\n      hasTag = false;\n      nonSpace = false;\n    }\n\n    var openingTagRe, closingTagRe, closingCurlyRe;\n    function compileTags(tags) {\n      if (typeof tags === 'string')\n        tags = tags.split(spaceRe, 2);\n\n      if (!isArray(tags) || tags.length !== 2)\n        throw new Error('Invalid tags: ' + tags);\n\n      openingTagRe = new RegExp(escapeRegExp(tags[0]) + '\\\\s*');\n      closingTagRe = new RegExp('\\\\s*' + escapeRegExp(tags[1]));\n      closingCurlyRe = new RegExp('\\\\s*' + escapeRegExp('}' + tags[1]));\n    }\n\n    compileTags(tags || mustache.tags);\n\n    var scanner = new Scanner(template);\n\n    var start, type, value, chr, token, openSection;\n    while (!scanner.eos()) {\n      start = scanner.pos;\n\n      // Match any text between tags.\n      value = scanner.scanUntil(openingTagRe);\n\n      if (value) {\n        for (var i = 0, valueLength = value.length; i < valueLength; ++i) {\n          chr = value.charAt(i);\n\n          if (isWhitespace(chr)) {\n            spaces.push(tokens.length);\n          } else {\n            nonSpace = true;\n          }\n\n          tokens.push([ 'text', chr, start, start + 1 ]);\n          start += 1;\n\n          // Check for whitespace on the current line.\n          if (chr === '\\n')\n            stripSpace();\n        }\n      }\n\n      // Match the opening tag.\n      if (!scanner.scan(openingTagRe))\n        break;\n\n      hasTag = true;\n\n      // Get the tag type.\n      type = scanner.scan(tagRe) || 'name';\n      scanner.scan(whiteRe);\n\n      // Get the tag value.\n      if (type === '=') {\n        value = scanner.scanUntil(equalsRe);\n        scanner.scan(equalsRe);\n        scanner.scanUntil(closingTagRe);\n      } else if (type === '{') {\n        value = scanner.scanUntil(closingCurlyRe);\n        scanner.scan(curlyRe);\n        scanner.scanUntil(closingTagRe);\n        type = '&';\n      } else {\n        value = scanner.scanUntil(closingTagRe);\n      }\n\n      // Match the closing tag.\n      if (!scanner.scan(closingTagRe))\n        throw new Error('Unclosed tag at ' + scanner.pos);\n\n      token = [ type, value, start, scanner.pos ];\n      tokens.push(token);\n\n      if (type === '#' || type === '^') {\n        sections.push(token);\n      } else if (type === '/') {\n        // Check section nesting.\n        openSection = sections.pop();\n\n        if (!openSection)\n          throw new Error('Unopened section \"' + value + '\" at ' + start);\n\n        if (openSection[1] !== value)\n          throw new Error('Unclosed section \"' + openSection[1] + '\" at ' + start);\n      } else if (type === 'name' || type === '{' || type === '&') {\n        nonSpace = true;\n      } else if (type === '=') {\n        // Set the tags for the next time around.\n        compileTags(value);\n      }\n    }\n\n    // Make sure there are no open sections when we're done.\n    openSection = sections.pop();\n\n    if (openSection)\n      throw new Error('Unclosed section \"' + openSection[1] + '\" at ' + scanner.pos);\n\n    return nestTokens(squashTokens(tokens));\n  }\n\n  /**\n   * Combines the values of consecutive text tokens in the given `tokens` array\n   * to a single token.\n   */\n  function squashTokens(tokens) {\n    var squashedTokens = [];\n\n    var token, lastToken;\n    for (var i = 0, numTokens = tokens.length; i < numTokens; ++i) {\n      token = tokens[i];\n\n      if (token) {\n        if (token[0] === 'text' && lastToken && lastToken[0] === 'text') {\n          lastToken[1] += token[1];\n          lastToken[3] = token[3];\n        } else {\n          squashedTokens.push(token);\n          lastToken = token;\n        }\n      }\n    }\n\n    return squashedTokens;\n  }\n\n  /**\n   * Forms the given array of `tokens` into a nested tree structure where\n   * tokens that represent a section have two additional items: 1) an array of\n   * all tokens that appear in that section and 2) the index in the original\n   * template that represents the end of that section.\n   */\n  function nestTokens(tokens) {\n    var nestedTokens = [];\n    var collector = nestedTokens;\n    var sections = [];\n\n    var token, section;\n    for (var i = 0, numTokens = tokens.length; i < numTokens; ++i) {\n      token = tokens[i];\n\n      switch (token[0]) {\n      case '#':\n      case '^':\n        collector.push(token);\n        sections.push(token);\n        collector = token[4] = [];\n        break;\n      case '/':\n        section = sections.pop();\n        section[5] = token[2];\n        collector = sections.length > 0 ? sections[sections.length - 1][4] : nestedTokens;\n        break;\n      default:\n        collector.push(token);\n      }\n    }\n\n    return nestedTokens;\n  }\n\n  /**\n   * A simple string scanner that is used by the template parser to find\n   * tokens in template strings.\n   */\n  function Scanner(string) {\n    this.string = string;\n    this.tail = string;\n    this.pos = 0;\n  }\n\n  /**\n   * Returns `true` if the tail is empty (end of string).\n   */\n  Scanner.prototype.eos = function () {\n    return this.tail === \"\";\n  };\n\n  /**\n   * Tries to match the given regular expression at the current position.\n   * Returns the matched text if it can match, the empty string otherwise.\n   */\n  Scanner.prototype.scan = function (re) {\n    var match = this.tail.match(re);\n\n    if (!match || match.index !== 0)\n      return '';\n\n    var string = match[0];\n\n    this.tail = this.tail.substring(string.length);\n    this.pos += string.length;\n\n    return string;\n  };\n\n  /**\n   * Skips all text until the given regular expression can be matched. Returns\n   * the skipped string, which is the entire tail if no match can be made.\n   */\n  Scanner.prototype.scanUntil = function (re) {\n    var index = this.tail.search(re), match;\n\n    switch (index) {\n    case -1:\n      match = this.tail;\n      this.tail = \"\";\n      break;\n    case 0:\n      match = \"\";\n      break;\n    default:\n      match = this.tail.substring(0, index);\n      this.tail = this.tail.substring(index);\n    }\n\n    this.pos += match.length;\n\n    return match;\n  };\n\n  /**\n   * Represents a rendering context by wrapping a view object and\n   * maintaining a reference to the parent context.\n   */\n  function Context(view, parentContext) {\n    this.view = view;\n    this.cache = { '.': this.view };\n    this.parent = parentContext;\n  }\n\n  /**\n   * Creates a new context using the given view with this context\n   * as the parent.\n   */\n  Context.prototype.push = function (view) {\n    return new Context(view, this);\n  };\n\n  /**\n   * Returns the value of the given name in this context, traversing\n   * up the context hierarchy if the value is absent in this context's view.\n   */\n  Context.prototype.lookup = function (name) {\n    var cache = this.cache;\n\n    var value;\n    if (name in cache) {\n      value = cache[name];\n    } else {\n      var context = this, names, index, lookupHit = false;\n\n      while (context) {\n        if (name.indexOf('.') > 0) {\n          value = context.view;\n          names = name.split('.');\n          index = 0;\n\n          /**\n           * Using the dot notion path in `name`, we descend through the\n           * nested objects.\n           *\n           * To be certain that the lookup has been successful, we have to\n           * check if the last object in the path actually has the property\n           * we are looking for. We store the result in `lookupHit`.\n           *\n           * This is specially necessary for when the value has been set to\n           * `undefined` and we want to avoid looking up parent contexts.\n           **/\n          while (value != null && index < names.length) {\n            if (index === names.length - 1 && value != null)\n              lookupHit = (typeof value === 'object') &&\n                value.hasOwnProperty(names[index]);\n            value = value[names[index++]];\n          }\n        } else if (context.view != null && typeof context.view === 'object') {\n          value = context.view[name];\n          lookupHit = context.view.hasOwnProperty(name);\n        }\n\n        if (lookupHit)\n          break;\n\n        context = context.parent;\n      }\n\n      cache[name] = value;\n    }\n\n    if (isFunction(value))\n      value = value.call(this.view);\n\n    return value;\n  };\n\n  /**\n   * A Writer knows how to take a stream of tokens and render them to a\n   * string, given a context. It also maintains a cache of templates to\n   * avoid the need to parse the same template twice.\n   */\n  function Writer() {\n    this.cache = {};\n  }\n\n  /**\n   * Clears all cached templates in this writer.\n   */\n  Writer.prototype.clearCache = function () {\n    this.cache = {};\n  };\n\n  /**\n   * Parses and caches the given `template` and returns the array of tokens\n   * that is generated from the parse.\n   */\n  Writer.prototype.parse = function (template, tags) {\n    var cache = this.cache;\n    var tokens = cache[template];\n\n    if (tokens == null)\n      tokens = cache[template] = parseTemplate(template, tags);\n\n    return tokens;\n  };\n\n  /**\n   * High-level method that is used to render the given `template` with\n   * the given `view`.\n   *\n   * The optional `partials` argument may be an object that contains the\n   * names and templates of partials that are used in the template. It may\n   * also be a function that is used to load partial templates on the fly\n   * that takes a single argument: the name of the partial.\n   */\n  Writer.prototype.render = function (template, view, partials) {\n    var tokens = this.parse(template);\n    var context = (view instanceof Context) ? view : new Context(view);\n    return this.renderTokens(tokens, context, partials, template);\n  };\n\n  /**\n   * Low-level method that renders the given array of `tokens` using\n   * the given `context` and `partials`.\n   *\n   * Note: The `originalTemplate` is only ever used to extract the portion\n   * of the original template that was contained in a higher-order section.\n   * If the template doesn't use higher-order sections, this argument may\n   * be omitted.\n   */\n  Writer.prototype.renderTokens = function (tokens, context, partials, originalTemplate) {\n    var buffer = '';\n\n    var token, symbol, value;\n    for (var i = 0, numTokens = tokens.length; i < numTokens; ++i) {\n      value = undefined;\n      token = tokens[i];\n      symbol = token[0];\n\n      if (symbol === '#') value = this._renderSection(token, context, partials, originalTemplate);\n      else if (symbol === '^') value = this._renderInverted(token, context, partials, originalTemplate);\n      else if (symbol === '>') value = this._renderPartial(token, context, partials, originalTemplate);\n      else if (symbol === '&') value = this._unescapedValue(token, context);\n      else if (symbol === 'name') value = this._escapedValue(token, context);\n      else if (symbol === 'text') value = this._rawValue(token);\n\n      if (value !== undefined)\n        buffer += value;\n    }\n\n    return buffer;\n  };\n\n  Writer.prototype._renderSection = function (token, context, partials, originalTemplate) {\n    var self = this;\n    var buffer = '';\n    var value = context.lookup(token[1]);\n\n    // This function is used to render an arbitrary template\n    // in the current context by higher-order sections.\n    function subRender(template) {\n      return self.render(template, context, partials);\n    }\n\n    if (!value) return;\n\n    if (isArray(value)) {\n      for (var j = 0, valueLength = value.length; j < valueLength; ++j) {\n        buffer += this.renderTokens(token[4], context.push(value[j]), partials, originalTemplate);\n      }\n    } else if (typeof value === 'object' || typeof value === 'string' || typeof value === 'number') {\n      buffer += this.renderTokens(token[4], context.push(value), partials, originalTemplate);\n    } else if (isFunction(value)) {\n      if (typeof originalTemplate !== 'string')\n        throw new Error('Cannot use higher-order sections without the original template');\n\n      // Extract the portion of the original template that the section contains.\n      value = value.call(context.view, originalTemplate.slice(token[3], token[5]), subRender);\n\n      if (value != null)\n        buffer += value;\n    } else {\n      buffer += this.renderTokens(token[4], context, partials, originalTemplate);\n    }\n    return buffer;\n  };\n\n  Writer.prototype._renderInverted = function(token, context, partials, originalTemplate) {\n    var value = context.lookup(token[1]);\n\n    // Use JavaScript's definition of falsy. Include empty arrays.\n    // See https://github.com/janl/mustache.js/issues/186\n    if (!value || (isArray(value) && value.length === 0))\n      return this.renderTokens(token[4], context, partials, originalTemplate);\n  };\n\n  Writer.prototype._renderPartial = function(token, context, partials) {\n    if (!partials) return;\n\n    var value = isFunction(partials) ? partials(token[1]) : partials[token[1]];\n    if (value != null)\n      return this.renderTokens(this.parse(value), context, partials, value);\n  };\n\n  Writer.prototype._unescapedValue = function(token, context) {\n    var value = context.lookup(token[1]);\n    if (value != null)\n      return value;\n  };\n\n  Writer.prototype._escapedValue = function(token, context) {\n    var value = context.lookup(token[1]);\n    if (value != null)\n      return mustache.escape(value);\n  };\n\n  Writer.prototype._rawValue = function(token) {\n    return token[1];\n  };\n\n  mustache.name = \"mustache.js\";\n  mustache.version = \"2.0.0\";\n  mustache.tags = [ \"{{\", \"}}\" ];\n\n  // All high-level mustache.* functions use this writer.\n  var defaultWriter = new Writer();\n\n  /**\n   * Clears all cached templates in the default writer.\n   */\n  mustache.clearCache = function () {\n    return defaultWriter.clearCache();\n  };\n\n  /**\n   * Parses and caches the given template in the default writer and returns the\n   * array of tokens it contains. Doing this ahead of time avoids the need to\n   * parse templates on the fly as they are rendered.\n   */\n  mustache.parse = function (template, tags) {\n    return defaultWriter.parse(template, tags);\n  };\n\n  /**\n   * Renders the `template` with the given `view` and `partials` using the\n   * default writer.\n   */\n  mustache.render = function (template, view, partials) {\n    return defaultWriter.render(template, view, partials);\n  };\n\n  // This is here for backwards compatibility with 0.4.x.\n  mustache.to_html = function (template, view, partials, send) {\n    var result = mustache.render(template, view, partials);\n\n    if (isFunction(send)) {\n      send(result);\n    } else {\n      return result;\n    }\n  };\n\n  // Export the escaping function so that the user may override it.\n  // See https://github.com/janl/mustache.js/issues/244\n  mustache.escape = escapeHtml;\n\n  // Export these mainly for testing, but also for advanced usage.\n  mustache.Scanner = Scanner;\n  mustache.Context = Context;\n  mustache.Writer = Writer;\n\n}));\n"}],"filteredModules":0,"origins":[{"moduleId":0,"module":"/Users/romain/Sites/Ships/landing-page/node_modules/babel-loader/index.js!/Users/romain/Sites/Ships/landing-page/src/ship.js","moduleIdentifier":"/Users/romain/Sites/Ships/landing-page/node_modules/babel-loader/index.js!/Users/romain/Sites/Ships/landing-page/src/ship.js","moduleName":"./src/ship.js","loc":"","name":"ship","reasons":[]}]}],"modules":[{"id":0,"identifier":"/Users/romain/Sites/Ships/landing-page/node_modules/babel-loader/index.js!/Users/romain/Sites/Ships/landing-page/src/ship.js","name":"./src/ship.js","size":1678,"cacheable":true,"built":true,"optional":false,"prefetched":false,"chunks":[0],"assets":[],"issuer":null,"failed":false,"errors":0,"warnings":0,"reasons":[],"source":"'use strict';\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\nvar _componentsStyles = require('./components/styles');\n\nvar _componentsStyles2 = _interopRequireDefault(_componentsStyles);\n\nvar _componentsTemplate = require('./components/template');\n\nvar _componentsTemplate2 = _interopRequireDefault(_componentsTemplate);\n\n(function () {\n\n  var getResizedImage = function getResizedImage(img, render) {\n    return 'http://proxy.boxresizer.com/convert?resize=500x332&source=' + encodeURIComponent(img);\n  };\n\n  var start = function start(rootElement, deployment, hull) {\n    var translate = function translate(string) {\n      return deployment.ship.translations.en[string];\n    };\n\n    var settings = deployment.ship.settings;\n    var translations = deployment.ship.translations.en;\n\n    var content = [];\n\n    var styles = (0, _componentsStyles2['default'])(settings);\n    content.push(styles);\n\n    var view = { settings: settings, translations: translations };\n    view.settings.logo = getResizedImage(view.settings.logo);\n\n    content.push((0, _componentsTemplate2['default'])('logo', view));\n    content.push((0, _componentsTemplate2['default'])('header', view));\n    content.push((0, _componentsTemplate2['default'])('tagline', view));\n    content.push((0, _componentsTemplate2['default'])('content', view));\n    content.push((0, _componentsTemplate2['default'])('cta', view));\n    content.push((0, _componentsTemplate2['default'])('images', view));\n\n    $(rootElement).find('.ship-root').empty().append('<div class=\"content\"><div class=\"container\">' + content.join('') + '</div></div>');\n  };\n  Hull.onEmbed(start);\n})();"},{"id":1,"identifier":"/Users/romain/Sites/Ships/landing-page/node_modules/babel-loader/index.js!/Users/romain/Sites/Ships/landing-page/src/components/styles.js","name":"./src/components/styles.js","size":1973,"cacheable":true,"built":true,"optional":false,"prefetched":false,"chunks":[0],"assets":[],"issuer":"/Users/romain/Sites/Ships/landing-page/node_modules/babel-loader/index.js!/Users/romain/Sites/Ships/landing-page/src/ship.js","failed":false,"errors":0,"warnings":0,"reasons":[{"moduleId":0,"moduleIdentifier":"/Users/romain/Sites/Ships/landing-page/node_modules/babel-loader/index.js!/Users/romain/Sites/Ships/landing-page/src/ship.js","module":"./src/ship.js","moduleName":"./src/ship.js","type":"cjs require","userRequest":"./components/styles","loc":"5:24-54"}],"source":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { \"default\": obj }; }\n\nvar _colorJs = require(\"color-js\");\n\nvar _colorJs2 = _interopRequireDefault(_colorJs);\n\nexports[\"default\"] = function (settings) {\n  var style = \"\\n    .ship-root {\\n      background: \" + settings.background_color + \";\\n      color: \" + settings.text_color + \";\\n    }\\n    h1, h2, h3, h4, h5, h6{\\n      color: \" + settings.title_color + \";\\n    }\\n    h1 small, h2 small, h3 small, h4 small, h5 small, h6 small{\\n      color: \" + (0, _colorJs2[\"default\"])(settings.title_color).setAlpha(0.6).toCSS() + \";\\n    }\\n    .btn{\\n      -webkit-border-radius:\" + settings.button_border_radius + \"px;\\n      -moz-border-radius:\" + settings.button_border_radius + \"px;\\n      -o-border-radius:\" + settings.button_border_radius + \"px;\\n      border-radius:\" + settings.button_border_radius + \"px;\\n    }\\n    .btn-main{\\n      color: \" + settings.button_text_color + \";\\n      border-color: \" + (0, _colorJs2[\"default\"])(settings.button_background_color).darkenByRatio(0.1).toCSS() + \";\\n      background-color: \" + settings.button_background_color + \";\\n    }\\n    .content::after{\\n      -webkit-filter: blur(\" + settings.background_blur + \"px);\\n      -moz-filter: blur(\" + settings.background_blur + \"px);\\n      -o-filter: blur(\" + settings.background_blur + \"px);\\n      -ms-filter: blur(\" + settings.background_blur + \"px);\\n      filter: blur(\" + settings.background_blur + \"px);\\n      opacity: \" + settings.background_opacity + \";\\n      position: absolute;\\n      z-index:-1;\\n      top:0;\\n      left:0;\\n      right:0;\\n      bottom:0;\\n      background:url('\" + settings.background_image + \"') repeat-x center top;\\n      background-size:cover;\\n    }\\n  \" + \".content::after{content:''}\";\n  return \"<style type='text/css'>\" + style + \"</style>\";\n};\n\nmodule.exports = exports[\"default\"];"},{"id":2,"identifier":"/Users/romain/Sites/Ships/landing-page/node_modules/babel-loader/index.js!/Users/romain/Sites/Ships/landing-page/src/components/template.js","name":"./src/components/template.js","size":2173,"cacheable":true,"built":true,"optional":false,"prefetched":false,"chunks":[0],"assets":[],"issuer":"/Users/romain/Sites/Ships/landing-page/node_modules/babel-loader/index.js!/Users/romain/Sites/Ships/landing-page/src/ship.js","failed":false,"errors":0,"warnings":0,"reasons":[{"moduleId":0,"moduleIdentifier":"/Users/romain/Sites/Ships/landing-page/node_modules/babel-loader/index.js!/Users/romain/Sites/Ships/landing-page/src/ship.js","module":"./src/ship.js","moduleName":"./src/ship.js","type":"cjs require","userRequest":"./components/template","loc":"9:26-58"}],"source":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { \"default\": obj }; }\n\nvar _mustache = require(\"mustache\");\n\nvar _mustache2 = _interopRequireDefault(_mustache);\n\nvar templates = {\n  logo: \"\\n    {{#settings.logo}}\\n      <div class=\\\"row logo_row\\\">\\n        <div class=\\\"mb-2 mt-1\\\">\\n          {{#settings.cta_link}}<a href=\\\"{{settings.cta_link}}\\\" target=\\\"_top\\\">{{/settings.cta_link}}\\n           <img src=\\\"{{settings.logo}}\\\" alt=\\\"\\\" width=\\\"160\\\" />\\n          {{#settings.cta_link}}</a>{{/settings.cta_link}}\\n        </div>\\n      </div\\n    {{/settings.logo}}\\n  \",\n\n  header: \"\\n    {{#translations.header}}\\n      <div class=\\\"row\\\">\\n        <div class=\\\"col-sm-12\\\">\\n          <h1>{{{translations.header}}}</h1>\\n        </div>\\n      </div>\\n    {{/translations.header}}\\n  \",\n\n  tagline: \"\\n    {{#translations.tagline}}\\n      <div class=\\\"row\\\">\\n        <div class=\\\"col-sm-12\\\">\\n          <h3>{{{translations.tagline}}}</h3>\\n        </div>\\n      </div>\\n    {{/translations.tagline}}\\n  \",\n\n  content: \"\\n    <div class=\\\"row\\\">\\n      <div class=\\\"col-sm-12\\\">\\n        <p>{{{translations.content}}}</p>\\n      </div>\\n    </div>\\n  \",\n\n  cta: \"\\n    {{#settings.cta_link}}\\n      <div class=\\\"row mt-2\\\">\\n        <div class=\\\"col-sm-8 col-sm-offset-2 col-md-6 col-md-offset-3\\\">\\n          <a href={{settings.cta_link}} class='btn btn-main btn-lg btn-block'>\\n            <span>{{{translations.call_to_action}}}</span>\\n          </a>\\n        </div>\\n      </div>\\n    {{/settings.cta_link}}\\n  \",\n\n  images: \"\\n    <div class=\\\"images pt-4 pb-4 row flex-row\\\">\\n      {{#settings.images}}\\n        <div class=\\\"col-xs-2 small-ps flex-item\\\">\\n          <img src=\\\"{{.}}\\\" class=\\\"img-responsive\\\" />\\n        </div>\\n      {{/settings.images}}\\n    </div>\\n  \"\n};\n\nexports[\"default\"] = function (template) {\n  var data = arguments[1] === undefined ? {} : arguments[1];\n\n  var t = templates[template];\n  if (t) {\n    return _mustache2[\"default\"].render(t, data);\n  } else {\n    return \"\";\n  }\n};\n\nmodule.exports = exports[\"default\"];"},{"id":3,"identifier":"/Users/romain/Sites/Ships/landing-page/node_modules/color-js/color.js","name":"./~/color-js/color.js","size":27073,"cacheable":true,"built":true,"optional":false,"prefetched":false,"chunks":[0],"assets":[],"issuer":"/Users/romain/Sites/Ships/landing-page/node_modules/babel-loader/index.js!/Users/romain/Sites/Ships/landing-page/src/components/styles.js","failed":false,"errors":0,"warnings":0,"reasons":[{"moduleId":1,"moduleIdentifier":"/Users/romain/Sites/Ships/landing-page/node_modules/babel-loader/index.js!/Users/romain/Sites/Ships/landing-page/src/components/styles.js","module":"./src/components/styles.js","moduleName":"./src/components/styles.js","type":"cjs require","userRequest":"color-js","loc":"9:15-34"}],"source":"// Copyright (c) 2008-2013, Andrew Brehaut, Tim Baumann, Matt Wilson, \n//                          Simon Heimler, Michel Vielmetter \n//\n// All rights reserved.\n//\n// Redistribution and use in source and binary forms, with or without\n// modification, are permitted provided that the following conditions are met:\n//\n// * Redistributions of source code must retain the above copyright notice,\n//   this list of conditions and the following disclaimer.\n// * Redistributions in binary form must reproduce the above copyright notice,\n//   this list of conditions and the following disclaimer in the documentation\n//   and/or other materials provided with the distribution.\n//\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n// ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE\n// LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n// CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n// SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n// INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n// CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n// POSSIBILITY OF SUCH DAMAGE.\n\n// color.js - version 1.0.1\n//\n// HSV <-> RGB code based on code from http://www.cs.rit.edu/~ncs/color/t_convert.html\n// object function created by Douglas Crockford.\n// Color scheme degrees taken from the colorjack.com colorpicker\n//\n// HSL support kindly provided by Tim Baumann - http://github.com/timjb\n\n// create namespaces\n/*global net */\nif (\"undefined\" == typeof net) { var net = {}; }\nif (!net.brehaut) { net.brehaut = {}; }\n\n// this module function is called with net.brehaut as 'this'\n(function ( ) {\n  \"use strict\";\n  // Constants\n\n  // css_colors maps color names onto their hex values\n  // these names are defined by W3C\n  var css_colors = {aliceblue:'#F0F8FF',antiquewhite:'#FAEBD7',aqua:'#00FFFF',aquamarine:'#7FFFD4',azure:'#F0FFFF',beige:'#F5F5DC',bisque:'#FFE4C4',black:'#000000',blanchedalmond:'#FFEBCD',blue:'#0000FF',blueviolet:'#8A2BE2',brown:'#A52A2A',burlywood:'#DEB887',cadetblue:'#5F9EA0',chartreuse:'#7FFF00',chocolate:'#D2691E',coral:'#FF7F50',cornflowerblue:'#6495ED',cornsilk:'#FFF8DC',crimson:'#DC143C',cyan:'#00FFFF',darkblue:'#00008B',darkcyan:'#008B8B',darkgoldenrod:'#B8860B',darkgray:'#A9A9A9',darkgrey:'#A9A9A9',darkgreen:'#006400',darkkhaki:'#BDB76B',darkmagenta:'#8B008B',darkolivegreen:'#556B2F',darkorange:'#FF8C00',darkorchid:'#9932CC',darkred:'#8B0000',darksalmon:'#E9967A',darkseagreen:'#8FBC8F',darkslateblue:'#483D8B',darkslategray:'#2F4F4F',darkslategrey:'#2F4F4F',darkturquoise:'#00CED1',darkviolet:'#9400D3',deeppink:'#FF1493',deepskyblue:'#00BFFF',dimgray:'#696969',dimgrey:'#696969',dodgerblue:'#1E90FF',firebrick:'#B22222',floralwhite:'#FFFAF0',forestgreen:'#228B22',fuchsia:'#FF00FF',gainsboro:'#DCDCDC',ghostwhite:'#F8F8FF',gold:'#FFD700',goldenrod:'#DAA520',gray:'#808080',grey:'#808080',green:'#008000',greenyellow:'#ADFF2F',honeydew:'#F0FFF0',hotpink:'#FF69B4',indianred:'#CD5C5C',indigo:'#4B0082',ivory:'#FFFFF0',khaki:'#F0E68C',lavender:'#E6E6FA',lavenderblush:'#FFF0F5',lawngreen:'#7CFC00',lemonchiffon:'#FFFACD',lightblue:'#ADD8E6',lightcoral:'#F08080',lightcyan:'#E0FFFF',lightgoldenrodyellow:'#FAFAD2',lightgray:'#D3D3D3',lightgrey:'#D3D3D3',lightgreen:'#90EE90',lightpink:'#FFB6C1',lightsalmon:'#FFA07A',lightseagreen:'#20B2AA',lightskyblue:'#87CEFA',lightslategray:'#778899',lightslategrey:'#778899',lightsteelblue:'#B0C4DE',lightyellow:'#FFFFE0',lime:'#00FF00',limegreen:'#32CD32',linen:'#FAF0E6',magenta:'#FF00FF',maroon:'#800000',mediumaquamarine:'#66CDAA',mediumblue:'#0000CD',mediumorchid:'#BA55D3',mediumpurple:'#9370D8',mediumseagreen:'#3CB371',mediumslateblue:'#7B68EE',mediumspringgreen:'#00FA9A',mediumturquoise:'#48D1CC',mediumvioletred:'#C71585',midnightblue:'#191970',mintcream:'#F5FFFA',mistyrose:'#FFE4E1',moccasin:'#FFE4B5',navajowhite:'#FFDEAD',navy:'#000080',oldlace:'#FDF5E6',olive:'#808000',olivedrab:'#6B8E23',orange:'#FFA500',orangered:'#FF4500',orchid:'#DA70D6',palegoldenrod:'#EEE8AA',palegreen:'#98FB98',paleturquoise:'#AFEEEE',palevioletred:'#D87093',papayawhip:'#FFEFD5',peachpuff:'#FFDAB9',peru:'#CD853F',pink:'#FFC0CB',plum:'#DDA0DD',powderblue:'#B0E0E6',purple:'#800080',rebeccapurple:'#663399',red:'#FF0000',rosybrown:'#BC8F8F',royalblue:'#4169E1',saddlebrown:'#8B4513',salmon:'#FA8072',sandybrown:'#F4A460',seagreen:'#2E8B57',seashell:'#FFF5EE',sienna:'#A0522D',silver:'#C0C0C0',skyblue:'#87CEEB',slateblue:'#6A5ACD',slategray:'#708090',slategrey:'#708090',snow:'#FFFAFA',springgreen:'#00FF7F',steelblue:'#4682B4',tan:'#D2B48C',teal:'#008080',thistle:'#D8BFD8',tomato:'#FF6347',turquoise:'#40E0D0',violet:'#EE82EE',wheat:'#F5DEB3',white:'#FFFFFF',whitesmoke:'#F5F5F5',yellow:'#FFFF00',yellowgreen:'#9ACD32'};\n\n  // CSS value regexes, according to http://www.w3.org/TR/css3-values/\n  var css_integer = '(?:\\\\+|-)?\\\\d+';\n  var css_float = '(?:\\\\+|-)?\\\\d*\\\\.\\\\d+';\n  var css_number = '(?:' + css_integer + ')|(?:' + css_float + ')';\n  css_integer = '(' + css_integer + ')';\n  css_float = '(' + css_float + ')';\n  css_number = '(' + css_number + ')';\n  var css_percentage = css_number + '%';\n  var css_whitespace = '\\\\s*?';\n\n  // http://www.w3.org/TR/2003/CR-css3-color-20030514/\n  var hsl_hsla_regex = new RegExp([\n    '^hsl(a?)\\\\(', css_number, ',', css_percentage, ',', css_percentage, '(,(', css_number, '))?\\\\)$'\n  ].join(css_whitespace) );\n  var rgb_rgba_integer_regex = new RegExp([\n    '^rgb(a?)\\\\(', css_integer, ',', css_integer, ',', css_integer, '(,(', css_number, '))?\\\\)$'\n  ].join(css_whitespace) );\n  var rgb_rgba_percentage_regex = new RegExp([\n    '^rgb(a?)\\\\(', css_percentage, ',', css_percentage, ',', css_percentage, '(,(', css_number, '))?\\\\)$'\n  ].join(css_whitespace) );\n\n  // Package wide variables\n\n  // becomes the top level prototype object\n  var color;\n\n  /* registered_models contains the template objects for all the\n   * models that have been registered for the color class.\n   */\n  var registered_models = [];\n\n\n  /* factories contains methods to create new instance of\n   * different color models that have been registered.\n   */\n  var factories = {};\n\n  // Utility functions\n\n  /* object is Douglas Crockfords object function for prototypal\n   * inheritance.\n   */\n  if (!this.object) {\n    this.object = function (o) {\n      function F () { }\n      F.prototype = o;\n      return new F();\n    };\n  }\n  var object = this.object;\n\n  /* takes a value, converts to string if need be, then pads it\n   * to a minimum length.\n   */\n  function pad ( val, len ) {\n    val = val.toString();\n    var padded = [];\n\n    for (var i = 0, j = Math.max( len - val.length, 0); i < j; i++) {\n      padded.push('0');\n    }\n\n    padded.push(val);\n    return padded.join('');\n  }\n\n\n  /* takes a string and returns a new string with the first letter\n   * capitalised\n   */\n  function capitalise ( s ) {\n    return s.slice(0,1).toUpperCase() + s.slice(1);\n  }\n\n  /* removes leading and trailing whitespace\n   */\n  function trim ( str ) {\n    return str.replace(/^\\s+|\\s+$/g, '');\n  }\n\n  /* used to apply a method to object non-destructively by\n   * cloning the object and then apply the method to that\n   * new object\n   */\n  function cloneOnApply( meth ) {\n    return function ( ) {\n      var cloned = this.clone();\n      meth.apply(cloned, arguments);\n      return cloned;\n    };\n  }\n\n\n  /* registerModel is used to add additional representations\n   * to the color code, and extend the color API with the new\n   * operation that model provides. see before for examples\n   */\n  function registerModel( name, model ) {\n    var proto = object(color);\n    var fields = []; // used for cloning and generating accessors\n\n    var to_meth = 'to'+ capitalise(name);\n\n    function convertAndApply( meth ) {\n      return function ( ) {\n        return meth.apply(this[to_meth](), arguments);\n      };\n    }\n\n    for (var key in model) if (model.hasOwnProperty(key)) {\n      proto[key] = model[key];\n      var prop = proto[key];\n\n      if (key.slice(0,1) == '_') { continue; }\n      if (!(key in color) && \"function\" == typeof prop) {\n        // the method found on this object is a) public and b) not\n        // currently supported by the color object. Create an impl that\n        // calls the toModel function and passes that new object\n        // onto the correct method with the args.\n        color[key] = convertAndApply(prop);\n      }\n      else if (\"function\" != typeof prop) {\n        // we have found a public property. create accessor methods\n        // and bind them up correctly\n        fields.push(key);\n        var getter = 'get'+capitalise(key);\n        var setter = 'set'+capitalise(key);\n\n        color[getter] = convertAndApply(\n          proto[getter] = (function ( key ) {\n            return function ( ) {\n              return this[key];\n            };\n          })( key )\n        );\n\n        color[setter] = convertAndApply(\n          proto[setter] = (function ( key ) {\n            return function ( val ) {\n              var cloned = this.clone();\n              cloned[key] = val;\n              return cloned;\n            };\n          })( key )\n        );\n      }\n    } // end of for over model\n\n    // a method to create a new object - largely so prototype chains dont\n    // get insane. This uses an unrolled 'object' so that F is cached\n    // for later use. this is approx a 25% speed improvement\n    function F () { }\n    F.prototype = proto;\n    function factory ( ) {\n      return new F();\n    }\n    factories[name] = factory;\n\n    proto.clone = function () {\n      var cloned = factory();\n      for (var i = 0, j = fields.length; i < j; i++) {\n        var key = fields[i];\n        cloned[key] = this[key];\n      }\n      return cloned;\n    };\n\n    color[to_meth] = function ( ) {\n      return factory();\n    };\n\n    registered_models.push(proto);\n\n    return proto;\n  }// end of registerModel\n\n  // Template Objects\n\n  /* color is the root object in the color hierarchy. It starts\n   * life as a very simple object, but as color models are\n   * registered it has methods programmatically added to manage\n   * conversions as needed.\n   */\n  color = {\n    /* fromObject takes an argument and delegates to the internal\n     * color models to try to create a new instance.\n     */\n    fromObject: function ( o ) {\n      if (!o) {\n        return object(color);\n      }\n\n      for (var i = 0, j = registered_models.length; i < j; i++) {\n        var nu = registered_models[i].fromObject(o);\n        if (nu) {\n          return nu;\n        }\n      }\n\n      return object(color);\n    },\n\n    toString: function ( ) {\n      return this.toCSS();\n    }\n  };\n\n  var transparent = null; // defined with an RGB later.\n\n  /* RGB is the red green blue model. This definition is converted\n   * to a template object by registerModel.\n   */\n  registerModel('RGB', {\n    red:    0,\n    green:  0,\n    blue:   0,\n    alpha:  0,\n\n    /* getLuminance returns a value between 0 and 1, this is the\n     * luminance calcuated according to\n     * http://www.poynton.com/notes/colour_and_gamma/ColorFAQ.html#RTFToC9\n     */\n    getLuminance: function ( ) {\n      return (this.red * 0.2126) + (this.green * 0.7152) + (this.blue * 0.0722);\n    },\n\n    /* does an alpha based blend of color onto this. alpha is the\n     * amount of 'color' to use. (0 to 1)\n     */\n    blend: function ( color , alpha ) {\n      color = color.toRGB();\n      alpha = Math.min(Math.max(alpha, 0), 1);\n      var rgb = this.clone();     \n\n      rgb.red = (rgb.red * (1 - alpha)) + (color.red * alpha);\n      rgb.green = (rgb.green * (1 - alpha)) + (color.green * alpha);\n      rgb.blue = (rgb.blue * (1 - alpha)) + (color.blue * alpha);\n      rgb.alpha = (rgb.alpha * (1 - alpha)) + (color.alpha * alpha);\n\n      return rgb;\n    },\n\n    /* fromObject attempts to convert an object o to and RGB\n     * instance. This accepts an object with red, green and blue\n     * members or a string. If the string is a known CSS color name\n     * or a hexdecimal string it will accept it.\n     */\n    fromObject: function ( o ) {\n      if (o instanceof Array) {\n        return this._fromRGBArray ( o );\n      }\n      if (\"string\" == typeof o) {\n        return this._fromCSS( trim( o ) );\n      }\n      if (o.hasOwnProperty('red') &&\n          o.hasOwnProperty('green') &&\n          o.hasOwnProperty('blue')) {\n        return this._fromRGB ( o );\n      }\n      // nothing matchs, not an RGB object\n    },\n\n    _stringParsers: [\n        // CSS RGB(A) literal:\n        function ( css ) {\n          css = trim(css);\n\n          var withInteger = match(rgb_rgba_integer_regex, 255);\n          if(withInteger) {\n            return withInteger;\n          }\n          return match(rgb_rgba_percentage_regex, 100);\n\n          function match(regex, max_value) {\n            var colorGroups = css.match( regex );\n\n            // If there is an \"a\" after \"rgb\", there must be a fourth parameter and the other way round\n            if (!colorGroups || (!!colorGroups[1] + !!colorGroups[5] === 1)) {\n              return null;\n            }\n\n            var rgb = factories.RGB();\n            rgb.red   = Math.min(1, Math.max(0, colorGroups[2] / max_value));\n            rgb.green = Math.min(1, Math.max(0, colorGroups[3] / max_value));\n            rgb.blue  = Math.min(1, Math.max(0, colorGroups[4] / max_value));\n            rgb.alpha = !!colorGroups[5] ? Math.min(Math.max(parseFloat(colorGroups[6]), 0), 1) : 1;\n\n            return rgb;\n          }\n        },\n\n        function ( css ) {\n            var lower = css.toLowerCase();\n            if (lower in css_colors) {\n              css = css_colors[lower];\n            }\n\n            if (!css.match(/^#([0-9a-fA-F]{3}|[0-9a-fA-F]{6})$/)) {\n              return;\n            }\n\n            css = css.replace(/^#/,'');\n\n            var bytes = css.length / 3;\n\n            var max = Math.pow(16, bytes) - 1;\n\n            var rgb = factories.RGB();\n            rgb.red =   parseInt(css.slice(0, bytes), 16) / max;\n            rgb.green = parseInt(css.slice(bytes * 1,bytes * 2), 16) / max;\n            rgb.blue =  parseInt(css.slice(bytes * 2), 16) / max;\n            rgb.alpha = 1;\n            return rgb;\n        },\n\n        function ( css ) {\n            if (css.toLowerCase() !== 'transparent') return;\n\n            return transparent;\n        }\n    ],\n\n    _fromCSS: function ( css ) {\n      var color = null;\n      for (var i = 0, j = this._stringParsers.length; i < j; i++) {\n          color = this._stringParsers[i](css);\n          if (color) return color;\n      }\n    },\n\n    _fromRGB: function ( RGB ) {\n      var newRGB = factories.RGB();\n\n      newRGB.red = RGB.red;\n      newRGB.green = RGB.green;\n      newRGB.blue = RGB.blue;\n      newRGB.alpha = RGB.hasOwnProperty('alpha') ? RGB.alpha : 1;\n\n      return newRGB;\n    },\n\n    _fromRGBArray: function ( RGB ) {\n      var newRGB = factories.RGB();\n\n      newRGB.red = Math.max(0, Math.min(1, RGB[0] / 255));\n      newRGB.green = Math.max(0, Math.min(1, RGB[1] / 255));\n      newRGB.blue = Math.max(0, Math.min(1, RGB[2] / 255));\n      newRGB.alpha = RGB[3] !== undefined ? Math.max(0, Math.min(1, RGB[3])) : 1;\n\n      return newRGB;\n    },\n\n    // convert to a CSS string. defaults to two bytes a value\n    toCSSHex: function ( bytes ) {\n        bytes = bytes || 2;\n\n        var max = Math.pow(16, bytes) - 1;\n        var css = [\n          \"#\",\n          pad ( Math.round(this.red * max).toString( 16 ).toUpperCase(), bytes ),\n          pad ( Math.round(this.green * max).toString( 16 ).toUpperCase(), bytes ),\n          pad ( Math.round(this.blue * max).toString( 16 ).toUpperCase(), bytes )\n        ];\n\n        return css.join('');\n    },    \n    \n    toCSS: function ( bytes ) {\n      if (this.alpha === 1) return this.toCSSHex(bytes); \n\n      var max = 255;\n      \n      var components = [\n        'rgba(',\n        Math.max(0, Math.min(max, Math.round(this.red * max))), ',',\n        Math.max(0, Math.min(max, Math.round(this.green * max))), ',', \n        Math.max(0, Math.min(max, Math.round(this.blue * max))), ',',\n        Math.max(0, Math.min(1, this.alpha)), \n        ')'\n      ];\n\n      return components.join('');\n    },\n\n    toHSV: function ( ) {\n      var hsv = factories.HSV();\n      var min, max, delta;\n\n      min = Math.min(this.red, this.green, this.blue);\n      max = Math.max(this.red, this.green, this.blue);\n      hsv.value = max; // v\n\n      delta = max - min;\n\n      if( delta == 0 ) { // white, grey, black\n        hsv.hue = hsv.saturation = 0;\n      }\n      else { // chroma\n        hsv.saturation = delta / max;\n\n        if( this.red == max ) {\n          hsv.hue = ( this.green - this.blue ) / delta; // between yellow & magenta\n        }\n        else if( this.green  == max ) {\n          hsv.hue = 2 + ( this.blue - this.red ) / delta; // between cyan & yellow\n        }\n        else {\n          hsv.hue = 4 + ( this.red - this.green ) / delta; // between magenta & cyan\n        }\n\n        hsv.hue = ((hsv.hue * 60) + 360) % 360; // degrees\n      }\n\n      hsv.alpha = this.alpha;\n\n      return hsv;\n    },\n    toHSL: function ( ) {\n      return this.toHSV().toHSL();\n    },\n\n    toRGB: function ( ) {\n      return this.clone();\n    }\n  });\n\n  transparent = color.fromObject({red: 0, blue: 0, green: 0, alpha: 0});\n\n\n  /* Like RGB above, this object describes what will become the HSV\n   * template object. This model handles hue, saturation and value.\n   * hue is the number of degrees around the color wheel, saturation\n   * describes how much color their is and value is the brightness.\n   */\n  registerModel('HSV', {\n    hue: 0,\n    saturation: 0,\n    value: 1,\n    alpha: 1,\n\n    shiftHue: cloneOnApply(function ( degrees ) {\n      var hue = (this.hue + degrees) % 360;\n      if (hue < 0) {\n        hue = (360 + hue) % 360;\n      }\n\n      this.hue = hue;\n    }),\n\n    devalueByAmount: cloneOnApply(function ( val ) {\n      this.value = Math.min(1, Math.max(this.value - val, 0));\n    }),\n\n    devalueByRatio: cloneOnApply(function ( val ) {\n      this.value = Math.min(1, Math.max(this.value * (1 - val), 0));\n    }),\n\n    valueByAmount: cloneOnApply(function ( val ) {\n      this.value = Math.min(1, Math.max(this.value + val, 0));\n    }),\n\n    valueByRatio: cloneOnApply(function ( val ) {\n      this.value = Math.min(1, Math.max(this.value * (1 + val), 0));\n    }),\n\n    desaturateByAmount: cloneOnApply(function ( val ) {\n      this.saturation = Math.min(1, Math.max(this.saturation - val, 0));\n    }),\n\n    desaturateByRatio: cloneOnApply(function ( val ) {\n      this.saturation = Math.min(1, Math.max(this.saturation * (1 - val), 0));\n    }),\n\n    saturateByAmount: cloneOnApply(function ( val ) {\n      this.saturation = Math.min(1, Math.max(this.saturation + val, 0));\n    }),\n\n    saturateByRatio: cloneOnApply(function ( val ) {\n      this.saturation = Math.min(1, Math.max(this.saturation * (1 + val), 0));\n    }),\n\n    schemeFromDegrees: function ( degrees ) {\n      var newColors = [];\n      for (var i = 0, j = degrees.length; i < j; i++) {\n        var col = this.clone();\n        col.hue = (this.hue + degrees[i]) % 360;\n        newColors.push(col);\n      }\n      return newColors;\n    },\n\n    complementaryScheme: function ( ) {\n      return this.schemeFromDegrees([0,180]);\n    },\n\n    splitComplementaryScheme: function ( ) {\n      return this.schemeFromDegrees([0,150,320]);\n    },\n\n    splitComplementaryCWScheme: function ( ) {\n      return this.schemeFromDegrees([0,150,300]);\n    },\n\n    splitComplementaryCCWScheme: function ( ) {\n      return this.schemeFromDegrees([0,60,210]);\n    },\n\n    triadicScheme: function ( ) {\n      return this.schemeFromDegrees([0,120,240]);\n    },\n\n    clashScheme: function ( ) {\n      return this.schemeFromDegrees([0,90,270]);\n    },\n\n    tetradicScheme: function ( ) {\n      return this.schemeFromDegrees([0,90,180,270]);\n    },\n\n    fourToneCWScheme: function ( ) {\n      return this.schemeFromDegrees([0,60,180,240]);\n    },\n\n    fourToneCCWScheme: function ( ) {\n      return this.schemeFromDegrees([0,120,180,300]);\n    },\n\n    fiveToneAScheme: function ( ) {\n      return this.schemeFromDegrees([0,115,155,205,245]);\n    },\n\n    fiveToneBScheme: function ( ) {\n      return this.schemeFromDegrees([0,40,90,130,245]);\n    },\n\n    fiveToneCScheme: function ( ) {\n      return this.schemeFromDegrees([0,50,90,205,320]);\n    },\n\n    fiveToneDScheme: function ( ) {\n      return this.schemeFromDegrees([0,40,155,270,310]);\n    },\n\n    fiveToneEScheme: function ( ) {\n      return this.schemeFromDegrees([0,115,230,270,320]);\n    },\n\n    sixToneCWScheme: function ( ) {\n      return this.schemeFromDegrees([0,30,120,150,240,270]);\n    },\n\n    sixToneCCWScheme: function ( ) {\n      return this.schemeFromDegrees([0,90,120,210,240,330]);\n    },\n\n    neutralScheme: function ( ) {\n      return this.schemeFromDegrees([0,15,30,45,60,75]);\n    },\n\n    analogousScheme: function ( ) {\n      return this.schemeFromDegrees([0,30,60,90,120,150]);\n    },\n\n    fromObject: function ( o ) {\n      if (o.hasOwnProperty('hue') &&\n          o.hasOwnProperty('saturation') &&\n          o.hasOwnProperty('value')) {\n        var hsv = factories.HSV();\n\n        hsv.hue = o.hue;\n        hsv.saturation = o.saturation;\n        hsv.value = o.value;\n        hsv.alpha = o.hasOwnProperty('alpha') ? o.alpha : 1;\n\n        return hsv;\n      }\n      // nothing matches, not an HSV object\n      return null;\n    },\n\n    _normalise: function ( ) {\n       this.hue %= 360;\n       this.saturation = Math.min(Math.max(0, this.saturation), 1);\n       this.value = Math.min(Math.max(0, this.value));\n       this.alpha = Math.min(1, Math.max(0, this.alpha));\n    },\n\n    toRGB: function ( ) {\n      this._normalise();\n\n      var rgb = factories.RGB();\n      var i;\n      var f, p, q, t;\n\n      if( this.saturation === 0 ) {\n        // achromatic (grey)\n        rgb.red = this.value;\n        rgb.green = this.value;\n        rgb.blue = this.value;\n        rgb.alpha = this.alpha;\n        return rgb;\n      }\n\n      var h = this.hue / 60;\t\t\t// sector 0 to 5\n      i = Math.floor( h );\n      f = h - i;\t\t\t// factorial part of h\n      p = this.value * ( 1 - this.saturation );\n      q = this.value * ( 1 - this.saturation * f );\n      t = this.value * ( 1 - this.saturation * ( 1 - f ) );\n\n      switch( i ) {\n        case 0:\n          rgb.red = this.value;\n          rgb.green = t;\n          rgb.blue = p;\n          break;\n        case 1:\n          rgb.red = q;\n          rgb.green = this.value;\n          rgb.blue = p;\n          break;\n        case 2:\n          rgb.red = p;\n          rgb.green = this.value;\n          rgb.blue = t;\n          break;\n        case 3:\n          rgb.red = p;\n          rgb.green = q;\n          rgb.blue = this.value;\n          break;\n        case 4:\n          rgb.red = t;\n          rgb.green = p;\n          rgb.blue = this.value;\n          break;\n        default:\t\t// case 5:\n          rgb.red = this.value;\n          rgb.green = p;\n          rgb.blue = q;\n          break;\n      }\n\n      rgb.alpha = this.alpha;\n\n      return rgb;\n    },\n    toHSL: function() {\n      this._normalise();\n\n      var hsl = factories.HSL();\n\n      hsl.hue = this.hue;\n      var l = (2 - this.saturation) * this.value,\n          s = this.saturation * this.value;\n      if(l && 2 - l) {\n        s /= (l <= 1) ? l : 2 - l;\n      }\n      l /= 2;\n      hsl.saturation = s;\n      hsl.lightness = l;\n      hsl.alpha = this.alpha;\n\n      return hsl;\n    },\n\n    toHSV: function ( ) {\n      return this.clone();\n    }\n  });\n\n  registerModel('HSL', {\n    hue: 0,\n    saturation: 0,\n    lightness: 0,\n    alpha: 1,\n\n    darkenByAmount: cloneOnApply(function ( val ) {\n      this.lightness = Math.min(1, Math.max(this.lightness - val, 0));\n    }),\n\n    darkenByRatio: cloneOnApply(function ( val ) {\n      this.lightness = Math.min(1, Math.max(this.lightness * (1 - val), 0));\n    }),\n\n    lightenByAmount: cloneOnApply(function ( val ) {\n      this.lightness = Math.min(1, Math.max(this.lightness + val, 0));\n    }),\n\n    lightenByRatio: cloneOnApply(function ( val ) {\n      this.lightness = Math.min(1, Math.max(this.lightness * (1 + val), 0));\n    }),\n\n    fromObject: function ( o ) {\n      if (\"string\" == typeof o) {\n        return this._fromCSS( o );\n      }\n      if (o.hasOwnProperty('hue') &&\n          o.hasOwnProperty('saturation') &&\n          o.hasOwnProperty('lightness')) {\n        return this._fromHSL ( o );\n      }\n      // nothing matchs, not an RGB object\n    },\n\n    _fromCSS: function ( css ) {\n      var colorGroups = trim( css ).match( hsl_hsla_regex );\n\n      // if there is an \"a\" after \"hsl\", there must be a fourth parameter and the other way round\n      if (!colorGroups || (!!colorGroups[1] + !!colorGroups[5] === 1)) {\n        return null;\n      }\n\n      var hsl = factories.HSL();\n      hsl.hue        = (colorGroups[2] % 360 + 360) % 360;\n      hsl.saturation = Math.max(0, Math.min(parseInt(colorGroups[3], 10) / 100, 1));\n      hsl.lightness  = Math.max(0, Math.min(parseInt(colorGroups[4], 10) / 100, 1));\n      hsl.alpha      = !!colorGroups[5] ? Math.max(0, Math.min(1, parseFloat(colorGroups[6]))) : 1;\n\n      return hsl;\n    },\n\n    _fromHSL: function ( HSL ) {\n      var newHSL = factories.HSL();\n\n      newHSL.hue = HSL.hue;\n      newHSL.saturation = HSL.saturation;\n      newHSL.lightness = HSL.lightness;\n\n      newHSL.alpha = HSL.hasOwnProperty('alpha') ? HSL.alpha : 1;\n\n      return newHSL;\n    },\n\n    _normalise: function ( ) {\n       this.hue = (this.hue % 360 + 360) % 360;\n       this.saturation = Math.min(Math.max(0, this.saturation), 1);\n       this.lightness = Math.min(Math.max(0, this.lightness));\n       this.alpha = Math.min(1, Math.max(0, this.alpha));\n    },\n\n    toHSL: function() {\n      return this.clone();\n    },\n    toHSV: function() {\n      this._normalise();\n\n      var hsv = factories.HSV();\n\n      // http://ariya.blogspot.com/2008/07/converting-between-hsl-and-hsv.html\n      hsv.hue = this.hue; // H\n      var l = 2 * this.lightness,\n          s = this.saturation * ((l <= 1) ? l : 2 - l);\n      hsv.value = (l + s) / 2; // V\n      hsv.saturation = ((2 * s) / (l + s)) || 0; // S\n      hsv.alpha = this.alpha;\n\n      return hsv;\n    },\n    toRGB: function() {\n      return this.toHSV().toRGB();\n    }\n  });\n\n  // Package specific exports\n\n  /* the Color function is a factory for new color objects.\n   */\n  function Color( o ) {\n    return color.fromObject( o );\n  }\n  Color.isValid = function( str ) {\n    var key, c = Color( str );\n\n    var length = 0;\n    for(key in c) {\n      if(c.hasOwnProperty(key)) {\n        length++;\n      }\n    }\n\n    return length > 0;\n  };\n  net.brehaut.Color = Color;\n}).call(net.brehaut);\n\n/* Export to CommonJS\n*/\nif(typeof module !== 'undefined') {\n  module.exports = net.brehaut.Color;\n}\n"},{"id":4,"identifier":"/Users/romain/Sites/Ships/landing-page/node_modules/mustache/mustache.js","name":"./~/mustache/mustache.js","size":18178,"cacheable":true,"built":true,"optional":false,"prefetched":false,"chunks":[0],"assets":[],"issuer":"/Users/romain/Sites/Ships/landing-page/node_modules/babel-loader/index.js!/Users/romain/Sites/Ships/landing-page/src/components/template.js","failed":false,"errors":0,"warnings":0,"reasons":[{"moduleId":2,"moduleIdentifier":"/Users/romain/Sites/Ships/landing-page/node_modules/babel-loader/index.js!/Users/romain/Sites/Ships/landing-page/src/components/template.js","module":"./src/components/template.js","moduleName":"./src/components/template.js","type":"cjs require","userRequest":"mustache","loc":"9:16-35"}],"source":"/*!\n * mustache.js - Logic-less {{mustache}} templates with JavaScript\n * http://github.com/janl/mustache.js\n */\n\n/*global define: false*/\n\n(function (global, factory) {\n  if (typeof exports === \"object\" && exports) {\n    factory(exports); // CommonJS\n  } else if (typeof define === \"function\" && define.amd) {\n    define(['exports'], factory); // AMD\n  } else {\n    factory(global.Mustache = {}); // <script>\n  }\n}(this, function (mustache) {\n\n  var Object_toString = Object.prototype.toString;\n  var isArray = Array.isArray || function (object) {\n    return Object_toString.call(object) === '[object Array]';\n  };\n\n  function isFunction(object) {\n    return typeof object === 'function';\n  }\n\n  function escapeRegExp(string) {\n    return string.replace(/[\\-\\[\\]{}()*+?.,\\\\\\^$|#\\s]/g, \"\\\\$&\");\n  }\n\n  // Workaround for https://issues.apache.org/jira/browse/COUCHDB-577\n  // See https://github.com/janl/mustache.js/issues/189\n  var RegExp_test = RegExp.prototype.test;\n  function testRegExp(re, string) {\n    return RegExp_test.call(re, string);\n  }\n\n  var nonSpaceRe = /\\S/;\n  function isWhitespace(string) {\n    return !testRegExp(nonSpaceRe, string);\n  }\n\n  var entityMap = {\n    \"&\": \"&amp;\",\n    \"<\": \"&lt;\",\n    \">\": \"&gt;\",\n    '\"': '&quot;',\n    \"'\": '&#39;',\n    \"/\": '&#x2F;'\n  };\n\n  function escapeHtml(string) {\n    return String(string).replace(/[&<>\"'\\/]/g, function (s) {\n      return entityMap[s];\n    });\n  }\n\n  var whiteRe = /\\s*/;\n  var spaceRe = /\\s+/;\n  var equalsRe = /\\s*=/;\n  var curlyRe = /\\s*\\}/;\n  var tagRe = /#|\\^|\\/|>|\\{|&|=|!/;\n\n  /**\n   * Breaks up the given `template` string into a tree of tokens. If the `tags`\n   * argument is given here it must be an array with two string values: the\n   * opening and closing tags used in the template (e.g. [ \"<%\", \"%>\" ]). Of\n   * course, the default is to use mustaches (i.e. mustache.tags).\n   *\n   * A token is an array with at least 4 elements. The first element is the\n   * mustache symbol that was used inside the tag, e.g. \"#\" or \"&\". If the tag\n   * did not contain a symbol (i.e. {{myValue}}) this element is \"name\". For\n   * all text that appears outside a symbol this element is \"text\".\n   *\n   * The second element of a token is its \"value\". For mustache tags this is\n   * whatever else was inside the tag besides the opening symbol. For text tokens\n   * this is the text itself.\n   *\n   * The third and fourth elements of the token are the start and end indices,\n   * respectively, of the token in the original template.\n   *\n   * Tokens that are the root node of a subtree contain two more elements: 1) an\n   * array of tokens in the subtree and 2) the index in the original template at\n   * which the closing tag for that section begins.\n   */\n  function parseTemplate(template, tags) {\n    if (!template)\n      return [];\n\n    var sections = [];     // Stack to hold section tokens\n    var tokens = [];       // Buffer to hold the tokens\n    var spaces = [];       // Indices of whitespace tokens on the current line\n    var hasTag = false;    // Is there a {{tag}} on the current line?\n    var nonSpace = false;  // Is there a non-space char on the current line?\n\n    // Strips all whitespace tokens array for the current line\n    // if there was a {{#tag}} on it and otherwise only space.\n    function stripSpace() {\n      if (hasTag && !nonSpace) {\n        while (spaces.length)\n          delete tokens[spaces.pop()];\n      } else {\n        spaces = [];\n      }\n\n      hasTag = false;\n      nonSpace = false;\n    }\n\n    var openingTagRe, closingTagRe, closingCurlyRe;\n    function compileTags(tags) {\n      if (typeof tags === 'string')\n        tags = tags.split(spaceRe, 2);\n\n      if (!isArray(tags) || tags.length !== 2)\n        throw new Error('Invalid tags: ' + tags);\n\n      openingTagRe = new RegExp(escapeRegExp(tags[0]) + '\\\\s*');\n      closingTagRe = new RegExp('\\\\s*' + escapeRegExp(tags[1]));\n      closingCurlyRe = new RegExp('\\\\s*' + escapeRegExp('}' + tags[1]));\n    }\n\n    compileTags(tags || mustache.tags);\n\n    var scanner = new Scanner(template);\n\n    var start, type, value, chr, token, openSection;\n    while (!scanner.eos()) {\n      start = scanner.pos;\n\n      // Match any text between tags.\n      value = scanner.scanUntil(openingTagRe);\n\n      if (value) {\n        for (var i = 0, valueLength = value.length; i < valueLength; ++i) {\n          chr = value.charAt(i);\n\n          if (isWhitespace(chr)) {\n            spaces.push(tokens.length);\n          } else {\n            nonSpace = true;\n          }\n\n          tokens.push([ 'text', chr, start, start + 1 ]);\n          start += 1;\n\n          // Check for whitespace on the current line.\n          if (chr === '\\n')\n            stripSpace();\n        }\n      }\n\n      // Match the opening tag.\n      if (!scanner.scan(openingTagRe))\n        break;\n\n      hasTag = true;\n\n      // Get the tag type.\n      type = scanner.scan(tagRe) || 'name';\n      scanner.scan(whiteRe);\n\n      // Get the tag value.\n      if (type === '=') {\n        value = scanner.scanUntil(equalsRe);\n        scanner.scan(equalsRe);\n        scanner.scanUntil(closingTagRe);\n      } else if (type === '{') {\n        value = scanner.scanUntil(closingCurlyRe);\n        scanner.scan(curlyRe);\n        scanner.scanUntil(closingTagRe);\n        type = '&';\n      } else {\n        value = scanner.scanUntil(closingTagRe);\n      }\n\n      // Match the closing tag.\n      if (!scanner.scan(closingTagRe))\n        throw new Error('Unclosed tag at ' + scanner.pos);\n\n      token = [ type, value, start, scanner.pos ];\n      tokens.push(token);\n\n      if (type === '#' || type === '^') {\n        sections.push(token);\n      } else if (type === '/') {\n        // Check section nesting.\n        openSection = sections.pop();\n\n        if (!openSection)\n          throw new Error('Unopened section \"' + value + '\" at ' + start);\n\n        if (openSection[1] !== value)\n          throw new Error('Unclosed section \"' + openSection[1] + '\" at ' + start);\n      } else if (type === 'name' || type === '{' || type === '&') {\n        nonSpace = true;\n      } else if (type === '=') {\n        // Set the tags for the next time around.\n        compileTags(value);\n      }\n    }\n\n    // Make sure there are no open sections when we're done.\n    openSection = sections.pop();\n\n    if (openSection)\n      throw new Error('Unclosed section \"' + openSection[1] + '\" at ' + scanner.pos);\n\n    return nestTokens(squashTokens(tokens));\n  }\n\n  /**\n   * Combines the values of consecutive text tokens in the given `tokens` array\n   * to a single token.\n   */\n  function squashTokens(tokens) {\n    var squashedTokens = [];\n\n    var token, lastToken;\n    for (var i = 0, numTokens = tokens.length; i < numTokens; ++i) {\n      token = tokens[i];\n\n      if (token) {\n        if (token[0] === 'text' && lastToken && lastToken[0] === 'text') {\n          lastToken[1] += token[1];\n          lastToken[3] = token[3];\n        } else {\n          squashedTokens.push(token);\n          lastToken = token;\n        }\n      }\n    }\n\n    return squashedTokens;\n  }\n\n  /**\n   * Forms the given array of `tokens` into a nested tree structure where\n   * tokens that represent a section have two additional items: 1) an array of\n   * all tokens that appear in that section and 2) the index in the original\n   * template that represents the end of that section.\n   */\n  function nestTokens(tokens) {\n    var nestedTokens = [];\n    var collector = nestedTokens;\n    var sections = [];\n\n    var token, section;\n    for (var i = 0, numTokens = tokens.length; i < numTokens; ++i) {\n      token = tokens[i];\n\n      switch (token[0]) {\n      case '#':\n      case '^':\n        collector.push(token);\n        sections.push(token);\n        collector = token[4] = [];\n        break;\n      case '/':\n        section = sections.pop();\n        section[5] = token[2];\n        collector = sections.length > 0 ? sections[sections.length - 1][4] : nestedTokens;\n        break;\n      default:\n        collector.push(token);\n      }\n    }\n\n    return nestedTokens;\n  }\n\n  /**\n   * A simple string scanner that is used by the template parser to find\n   * tokens in template strings.\n   */\n  function Scanner(string) {\n    this.string = string;\n    this.tail = string;\n    this.pos = 0;\n  }\n\n  /**\n   * Returns `true` if the tail is empty (end of string).\n   */\n  Scanner.prototype.eos = function () {\n    return this.tail === \"\";\n  };\n\n  /**\n   * Tries to match the given regular expression at the current position.\n   * Returns the matched text if it can match, the empty string otherwise.\n   */\n  Scanner.prototype.scan = function (re) {\n    var match = this.tail.match(re);\n\n    if (!match || match.index !== 0)\n      return '';\n\n    var string = match[0];\n\n    this.tail = this.tail.substring(string.length);\n    this.pos += string.length;\n\n    return string;\n  };\n\n  /**\n   * Skips all text until the given regular expression can be matched. Returns\n   * the skipped string, which is the entire tail if no match can be made.\n   */\n  Scanner.prototype.scanUntil = function (re) {\n    var index = this.tail.search(re), match;\n\n    switch (index) {\n    case -1:\n      match = this.tail;\n      this.tail = \"\";\n      break;\n    case 0:\n      match = \"\";\n      break;\n    default:\n      match = this.tail.substring(0, index);\n      this.tail = this.tail.substring(index);\n    }\n\n    this.pos += match.length;\n\n    return match;\n  };\n\n  /**\n   * Represents a rendering context by wrapping a view object and\n   * maintaining a reference to the parent context.\n   */\n  function Context(view, parentContext) {\n    this.view = view;\n    this.cache = { '.': this.view };\n    this.parent = parentContext;\n  }\n\n  /**\n   * Creates a new context using the given view with this context\n   * as the parent.\n   */\n  Context.prototype.push = function (view) {\n    return new Context(view, this);\n  };\n\n  /**\n   * Returns the value of the given name in this context, traversing\n   * up the context hierarchy if the value is absent in this context's view.\n   */\n  Context.prototype.lookup = function (name) {\n    var cache = this.cache;\n\n    var value;\n    if (name in cache) {\n      value = cache[name];\n    } else {\n      var context = this, names, index, lookupHit = false;\n\n      while (context) {\n        if (name.indexOf('.') > 0) {\n          value = context.view;\n          names = name.split('.');\n          index = 0;\n\n          /**\n           * Using the dot notion path in `name`, we descend through the\n           * nested objects.\n           *\n           * To be certain that the lookup has been successful, we have to\n           * check if the last object in the path actually has the property\n           * we are looking for. We store the result in `lookupHit`.\n           *\n           * This is specially necessary for when the value has been set to\n           * `undefined` and we want to avoid looking up parent contexts.\n           **/\n          while (value != null && index < names.length) {\n            if (index === names.length - 1 && value != null)\n              lookupHit = (typeof value === 'object') &&\n                value.hasOwnProperty(names[index]);\n            value = value[names[index++]];\n          }\n        } else if (context.view != null && typeof context.view === 'object') {\n          value = context.view[name];\n          lookupHit = context.view.hasOwnProperty(name);\n        }\n\n        if (lookupHit)\n          break;\n\n        context = context.parent;\n      }\n\n      cache[name] = value;\n    }\n\n    if (isFunction(value))\n      value = value.call(this.view);\n\n    return value;\n  };\n\n  /**\n   * A Writer knows how to take a stream of tokens and render them to a\n   * string, given a context. It also maintains a cache of templates to\n   * avoid the need to parse the same template twice.\n   */\n  function Writer() {\n    this.cache = {};\n  }\n\n  /**\n   * Clears all cached templates in this writer.\n   */\n  Writer.prototype.clearCache = function () {\n    this.cache = {};\n  };\n\n  /**\n   * Parses and caches the given `template` and returns the array of tokens\n   * that is generated from the parse.\n   */\n  Writer.prototype.parse = function (template, tags) {\n    var cache = this.cache;\n    var tokens = cache[template];\n\n    if (tokens == null)\n      tokens = cache[template] = parseTemplate(template, tags);\n\n    return tokens;\n  };\n\n  /**\n   * High-level method that is used to render the given `template` with\n   * the given `view`.\n   *\n   * The optional `partials` argument may be an object that contains the\n   * names and templates of partials that are used in the template. It may\n   * also be a function that is used to load partial templates on the fly\n   * that takes a single argument: the name of the partial.\n   */\n  Writer.prototype.render = function (template, view, partials) {\n    var tokens = this.parse(template);\n    var context = (view instanceof Context) ? view : new Context(view);\n    return this.renderTokens(tokens, context, partials, template);\n  };\n\n  /**\n   * Low-level method that renders the given array of `tokens` using\n   * the given `context` and `partials`.\n   *\n   * Note: The `originalTemplate` is only ever used to extract the portion\n   * of the original template that was contained in a higher-order section.\n   * If the template doesn't use higher-order sections, this argument may\n   * be omitted.\n   */\n  Writer.prototype.renderTokens = function (tokens, context, partials, originalTemplate) {\n    var buffer = '';\n\n    var token, symbol, value;\n    for (var i = 0, numTokens = tokens.length; i < numTokens; ++i) {\n      value = undefined;\n      token = tokens[i];\n      symbol = token[0];\n\n      if (symbol === '#') value = this._renderSection(token, context, partials, originalTemplate);\n      else if (symbol === '^') value = this._renderInverted(token, context, partials, originalTemplate);\n      else if (symbol === '>') value = this._renderPartial(token, context, partials, originalTemplate);\n      else if (symbol === '&') value = this._unescapedValue(token, context);\n      else if (symbol === 'name') value = this._escapedValue(token, context);\n      else if (symbol === 'text') value = this._rawValue(token);\n\n      if (value !== undefined)\n        buffer += value;\n    }\n\n    return buffer;\n  };\n\n  Writer.prototype._renderSection = function (token, context, partials, originalTemplate) {\n    var self = this;\n    var buffer = '';\n    var value = context.lookup(token[1]);\n\n    // This function is used to render an arbitrary template\n    // in the current context by higher-order sections.\n    function subRender(template) {\n      return self.render(template, context, partials);\n    }\n\n    if (!value) return;\n\n    if (isArray(value)) {\n      for (var j = 0, valueLength = value.length; j < valueLength; ++j) {\n        buffer += this.renderTokens(token[4], context.push(value[j]), partials, originalTemplate);\n      }\n    } else if (typeof value === 'object' || typeof value === 'string' || typeof value === 'number') {\n      buffer += this.renderTokens(token[4], context.push(value), partials, originalTemplate);\n    } else if (isFunction(value)) {\n      if (typeof originalTemplate !== 'string')\n        throw new Error('Cannot use higher-order sections without the original template');\n\n      // Extract the portion of the original template that the section contains.\n      value = value.call(context.view, originalTemplate.slice(token[3], token[5]), subRender);\n\n      if (value != null)\n        buffer += value;\n    } else {\n      buffer += this.renderTokens(token[4], context, partials, originalTemplate);\n    }\n    return buffer;\n  };\n\n  Writer.prototype._renderInverted = function(token, context, partials, originalTemplate) {\n    var value = context.lookup(token[1]);\n\n    // Use JavaScript's definition of falsy. Include empty arrays.\n    // See https://github.com/janl/mustache.js/issues/186\n    if (!value || (isArray(value) && value.length === 0))\n      return this.renderTokens(token[4], context, partials, originalTemplate);\n  };\n\n  Writer.prototype._renderPartial = function(token, context, partials) {\n    if (!partials) return;\n\n    var value = isFunction(partials) ? partials(token[1]) : partials[token[1]];\n    if (value != null)\n      return this.renderTokens(this.parse(value), context, partials, value);\n  };\n\n  Writer.prototype._unescapedValue = function(token, context) {\n    var value = context.lookup(token[1]);\n    if (value != null)\n      return value;\n  };\n\n  Writer.prototype._escapedValue = function(token, context) {\n    var value = context.lookup(token[1]);\n    if (value != null)\n      return mustache.escape(value);\n  };\n\n  Writer.prototype._rawValue = function(token) {\n    return token[1];\n  };\n\n  mustache.name = \"mustache.js\";\n  mustache.version = \"2.0.0\";\n  mustache.tags = [ \"{{\", \"}}\" ];\n\n  // All high-level mustache.* functions use this writer.\n  var defaultWriter = new Writer();\n\n  /**\n   * Clears all cached templates in the default writer.\n   */\n  mustache.clearCache = function () {\n    return defaultWriter.clearCache();\n  };\n\n  /**\n   * Parses and caches the given template in the default writer and returns the\n   * array of tokens it contains. Doing this ahead of time avoids the need to\n   * parse templates on the fly as they are rendered.\n   */\n  mustache.parse = function (template, tags) {\n    return defaultWriter.parse(template, tags);\n  };\n\n  /**\n   * Renders the `template` with the given `view` and `partials` using the\n   * default writer.\n   */\n  mustache.render = function (template, view, partials) {\n    return defaultWriter.render(template, view, partials);\n  };\n\n  // This is here for backwards compatibility with 0.4.x.\n  mustache.to_html = function (template, view, partials, send) {\n    var result = mustache.render(template, view, partials);\n\n    if (isFunction(send)) {\n      send(result);\n    } else {\n      return result;\n    }\n  };\n\n  // Export the escaping function so that the user may override it.\n  // See https://github.com/janl/mustache.js/issues/244\n  mustache.escape = escapeHtml;\n\n  // Export these mainly for testing, but also for advanced usage.\n  mustache.Scanner = Scanner;\n  mustache.Context = Context;\n  mustache.Writer = Writer;\n\n}));\n"}],"filteredModules":0,"children":[]}